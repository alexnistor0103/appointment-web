This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2025-03-23T14:36:01.319Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

For more information about Repomix, visit: https://github.com/yamadashy/repomix

================================================================
Directory Structure
================================================================
.gitignore
eslint.config.js
index.html
LICENSE
package.json
public/vite.svg
README.md
src/App.css
src/App.tsx
src/assets/react.svg
src/components/auth/LoginForm.tsx
src/components/auth/RegisterForm.tsx
src/components/common/Navbar.tsx
src/components/common/ProtectedRoute.tsx
src/hooks/useAppointments.ts
src/hooks/useAuth.ts
src/main.tsx
src/pages/AppointmentDetailsPage.tsx
src/pages/AppointmentsPage.tsx
src/pages/DashboardPage.tsx
src/pages/EditAppointmentPage.tsx
src/pages/HomePage.tsx
src/pages/LoginPage.tsx
src/pages/NewAppointmentPage.tsx
src/pages/NotFoundPage.tsx
src/pages/RegisterPage.tsx
src/pages/ServiceManagementPage.tsx
src/store/appointmentSlice.ts
src/store/authSlice.ts
src/store/store.ts
src/types/appointment.ts
src/types/index.ts
src/utils/appointmentApi.ts
src/utils/axios.ts
src/utils/tokenUtils.ts
src/vite-env.d.ts
tsconfig.app.json
tsconfig.json
tsconfig.node.json
vite.config.ts
web.txt

================================================================
Files
================================================================

================
File: .gitignore
================
# Logs
logs
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*
pnpm-debug.log*
lerna-debug.log*

node_modules
dist
dist-ssr
*.local

# Editor directories and files
.vscode/*
!.vscode/extensions.json
.idea
.DS_Store
*.suo
*.ntvs*
*.njsproj
*.sln
*.sw?

================
File: eslint.config.js
================
import js from '@eslint/js'
import globals from 'globals'
import reactHooks from 'eslint-plugin-react-hooks'
import reactRefresh from 'eslint-plugin-react-refresh'
import tseslint from 'typescript-eslint'

export default tseslint.config(
  { ignores: ['dist'] },
  {
    extends: [js.configs.recommended, ...tseslint.configs.recommended],
    files: ['**/*.{ts,tsx}'],
    languageOptions: {
      ecmaVersion: 2020,
      globals: globals.browser,
    },
    plugins: {
      'react-hooks': reactHooks,
      'react-refresh': reactRefresh,
    },
    rules: {
      ...reactHooks.configs.recommended.rules,
      'react-refresh/only-export-components': [
        'warn',
        { allowConstantExport: true },
      ],
    },
  },
)

================
File: index.html
================
<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="/vite.svg" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Vite + React + TS</title>
  </head>
  <body>
    <div id="root"></div>
    <script type="module" src="/src/main.tsx"></script>
  </body>
</html>

================
File: LICENSE
================
MIT License

Copyright (c) 2025 alexnistor0103

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

================
File: package.json
================
{
  "name": "vite-react-typescript-starter",
  "private": true,
  "version": "0.0.0",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "tsc -b && vite build",
    "lint": "eslint .",
    "preview": "vite preview"
  },
  "dependencies": {
    "@emotion/react": "^11.14.0",
    "@emotion/styled": "^11.14.0",
    "@mui/icons-material": "^5.17.1",
    "@mui/material": "^5.17.1",
    "@mui/x-date-pickers": "^7.28.0",
    "@reduxjs/toolkit": "^2.0.1",
    "axios": "^1.6.3",
    "date-fns": "^2.29.3",
    "react": "^18.2.0",
    "react-dom": "^18.2.0",
    "react-redux": "^9.0.4",
    "react-router-dom": "^6.21.1"
  },
  "devDependencies": {
    "@eslint/js": "^8.56.0",
    "@types/react": "^18.2.45",
    "@types/react-dom": "^18.2.18",
    "@vitejs/plugin-react": "^4.2.1",
    "eslint": "^8.56.0",
    "eslint-plugin-react-hooks": "^4.6.0",
    "eslint-plugin-react-refresh": "^0.4.5",
    "globals": "^13.24.0",
    "typescript": "^5.3.3",
    "typescript-eslint": "^7.0.0",
    "vite": "^5.0.10"
  }
}

================
File: public/vite.svg
================
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" role="img" class="iconify iconify--logos" width="31.88" height="32" preserveAspectRatio="xMidYMid meet" viewBox="0 0 256 257"><defs><linearGradient id="IconifyId1813088fe1fbc01fb466" x1="-.828%" x2="57.636%" y1="7.652%" y2="78.411%"><stop offset="0%" stop-color="#41D1FF"></stop><stop offset="100%" stop-color="#BD34FE"></stop></linearGradient><linearGradient id="IconifyId1813088fe1fbc01fb467" x1="43.376%" x2="50.316%" y1="2.242%" y2="89.03%"><stop offset="0%" stop-color="#FFEA83"></stop><stop offset="8.333%" stop-color="#FFDD35"></stop><stop offset="100%" stop-color="#FFA800"></stop></linearGradient></defs><path fill="url(#IconifyId1813088fe1fbc01fb466)" d="M255.153 37.938L134.897 252.976c-2.483 4.44-8.862 4.466-11.382.048L.875 37.958c-2.746-4.814 1.371-10.646 6.827-9.67l120.385 21.517a6.537 6.537 0 0 0 2.322-.004l117.867-21.483c5.438-.991 9.574 4.796 6.877 9.62Z"></path><path fill="url(#IconifyId1813088fe1fbc01fb467)" d="M185.432.063L96.44 17.501a3.268 3.268 0 0 0-2.634 3.014l-5.474 92.456a3.268 3.268 0 0 0 3.997 3.378l24.777-5.718c2.318-.535 4.413 1.507 3.936 3.838l-7.361 36.047c-.495 2.426 1.782 4.5 4.151 3.78l15.304-4.649c2.372-.72 4.652 1.36 4.15 3.788l-11.698 56.621c-.732 3.542 3.979 5.473 5.943 2.437l1.313-2.028l72.516-144.72c1.215-2.423-.88-5.186-3.54-4.672l-25.505 4.922c-2.396.462-4.435-1.77-3.759-4.114l16.646-57.705c.677-2.35-1.37-4.583-3.769-4.113Z"></path></svg>

================
File: README.md
================
# React + TypeScript + Vite

This template provides a minimal setup to get React working in Vite with HMR and some ESLint rules.

Currently, two official plugins are available:

- [@vitejs/plugin-react](https://github.com/vitejs/vite-plugin-react/blob/main/packages/plugin-react/README.md) uses [Babel](https://babeljs.io/) for Fast Refresh
- [@vitejs/plugin-react-swc](https://github.com/vitejs/vite-plugin-react-swc) uses [SWC](https://swc.rs/) for Fast Refresh

## Expanding the ESLint configuration

If you are developing a production application, we recommend updating the configuration to enable type-aware lint rules:

```js
export default tseslint.config({
  extends: [
    // Remove ...tseslint.configs.recommended and replace with this
    ...tseslint.configs.recommendedTypeChecked,
    // Alternatively, use this for stricter rules
    ...tseslint.configs.strictTypeChecked,
    // Optionally, add this for stylistic rules
    ...tseslint.configs.stylisticTypeChecked,
  ],
  languageOptions: {
    // other options...
    parserOptions: {
      project: ['./tsconfig.node.json', './tsconfig.app.json'],
      tsconfigRootDir: import.meta.dirname,
    },
  },
})
```

You can also install [eslint-plugin-react-x](https://github.com/Rel1cx/eslint-react/tree/main/packages/plugins/eslint-plugin-react-x) and [eslint-plugin-react-dom](https://github.com/Rel1cx/eslint-react/tree/main/packages/plugins/eslint-plugin-react-dom) for React-specific lint rules:

```js
// eslint.config.js
import reactX from 'eslint-plugin-react-x'
import reactDom from 'eslint-plugin-react-dom'

export default tseslint.config({
  plugins: {
    // Add the react-x and react-dom plugins
    'react-x': reactX,
    'react-dom': reactDom,
  },
  rules: {
    // other rules...
    // Enable its recommended typescript rules
    ...reactX.configs['recommended-typescript'].rules,
    ...reactDom.configs.recommended.rules,
  },
})
```

================
File: src/App.css
================
#root {
  max-width: 1280px;
  margin: 0 auto;
  padding: 2rem;
  text-align: center;
}

.logo {
  height: 6em;
  padding: 1.5em;
  will-change: filter;
  transition: filter 300ms;
}
.logo:hover {
  filter: drop-shadow(0 0 2em #646cffaa);
}
.logo.react:hover {
  filter: drop-shadow(0 0 2em #61dafbaa);
}

@keyframes logo-spin {
  from {
    transform: rotate(0deg);
  }
  to {
    transform: rotate(360deg);
  }
}

@media (prefers-reduced-motion: no-preference) {
  a:nth-of-type(2) .logo {
    animation: logo-spin infinite 20s linear;
  }
}

.card {
  padding: 2em;
}

.read-the-docs {
  color: #888;
}

================
File: src/App.tsx
================
// src/App.tsx
import React from 'react';
import { BrowserRouter, Routes, Route, Navigate } from 'react-router-dom';
import { Provider } from 'react-redux';
import { store } from './store/store';
import { ThemeProvider, createTheme, CssBaseline } from '@mui/material';
import { LocalizationProvider } from '@mui/x-date-pickers/LocalizationProvider';
import { AdapterDateFns } from '@mui/x-date-pickers/AdapterDateFns';
import Navbar from './components/common/Navbar';
import ProtectedRoute from './components/common/ProtectedRoute';

// Pages
import HomePage from './pages/HomePage';
import LoginPage from './pages/LoginPage';
import RegisterPage from './pages/RegisterPage';
import DashboardPage from './pages/DashboardPage';
import AppointmentsPage from './pages/AppointmentsPage';
import AppointmentDetailsPage from './pages/AppointmentDetailsPage';
import NewAppointmentPage from './pages/NewAppointmentPage';
import EditAppointmentPage from './pages/EditAppointmentPage';
import ServiceManagementPage from './pages/ServiceManagementPage';
import NotFoundPage from './pages/NotFoundPage';

// Create a theme
const theme = createTheme({
  palette: {
    primary: {
      main: '#8e44ad', // Purple color for Dasha's Nails
    },
    secondary: {
      main: '#e74c3c', // Red accent color
    },
  },
  typography: {
    fontFamily: [
      '"Poppins"',
      '"Roboto"',
      'sans-serif'
    ].join(','),
  }
});

function App() {
  return (
    <Provider store={store}>
      <ThemeProvider theme={theme}>
        <LocalizationProvider dateAdapter={AdapterDateFns}>
          <CssBaseline />
          <BrowserRouter>
            <Navbar />
            <Routes>
              {/* Public routes */}
              <Route path="/" element={<HomePage />} />
              <Route path="/login" element={<LoginPage />} />
              <Route path="/register" element={<RegisterPage />} />
              
              {/* Protected routes */}
              <Route
                path="/dashboard"
                element={
                  <ProtectedRoute>
                    <DashboardPage />
                  </ProtectedRoute>
                }
              />
              <Route
                path="/appointments"
                element={
                  <ProtectedRoute>
                    <AppointmentsPage />
                  </ProtectedRoute>
                }
              />
              <Route
                path="/appointments/:id"
                element={
                  <ProtectedRoute>
                    <AppointmentDetailsPage />
                  </ProtectedRoute>
                }
              />
              <Route
                path="/appointments/new"
                element={
                  <ProtectedRoute>
                    <NewAppointmentPage />
                  </ProtectedRoute>
                }
              />
              <Route
                path="/appointments/edit/:id"
                element={
                  <ProtectedRoute>
                    <EditAppointmentPage />
                  </ProtectedRoute>
                }
              />
              
              {/* Admin routes */}
              <Route
                path="/admin/services"
                element={
                  <ProtectedRoute>
                    <ServiceManagementPage />
                  </ProtectedRoute>
                }
              />
              
              {/* Error pages */}
              <Route path="/404" element={<NotFoundPage />} />
              <Route path="*" element={<Navigate to="/404" />} />
            </Routes>
          </BrowserRouter>
        </LocalizationProvider>
      </ThemeProvider>
    </Provider>
  );
}

export default App;

================
File: src/assets/react.svg
================
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" role="img" class="iconify iconify--logos" width="35.93" height="32" preserveAspectRatio="xMidYMid meet" viewBox="0 0 256 228"><path fill="#00D8FF" d="M210.483 73.824a171.49 171.49 0 0 0-8.24-2.597c.465-1.9.893-3.777 1.273-5.621c6.238-30.281 2.16-54.676-11.769-62.708c-13.355-7.7-35.196.329-57.254 19.526a171.23 171.23 0 0 0-6.375 5.848a155.866 155.866 0 0 0-4.241-3.917C100.759 3.829 77.587-4.822 63.673 3.233C50.33 10.957 46.379 33.89 51.995 62.588a170.974 170.974 0 0 0 1.892 8.48c-3.28.932-6.445 1.924-9.474 2.98C17.309 83.498 0 98.307 0 113.668c0 15.865 18.582 31.778 46.812 41.427a145.52 145.52 0 0 0 6.921 2.165a167.467 167.467 0 0 0-2.01 9.138c-5.354 28.2-1.173 50.591 12.134 58.266c13.744 7.926 36.812-.22 59.273-19.855a145.567 145.567 0 0 0 5.342-4.923a168.064 168.064 0 0 0 6.92 6.314c21.758 18.722 43.246 26.282 56.54 18.586c13.731-7.949 18.194-32.003 12.4-61.268a145.016 145.016 0 0 0-1.535-6.842c1.62-.48 3.21-.974 4.76-1.488c29.348-9.723 48.443-25.443 48.443-41.52c0-15.417-17.868-30.326-45.517-39.844Zm-6.365 70.984c-1.4.463-2.836.91-4.3 1.345c-3.24-10.257-7.612-21.163-12.963-32.432c5.106-11 9.31-21.767 12.459-31.957c2.619.758 5.16 1.557 7.61 2.4c23.69 8.156 38.14 20.213 38.14 29.504c0 9.896-15.606 22.743-40.946 31.14Zm-10.514 20.834c2.562 12.94 2.927 24.64 1.23 33.787c-1.524 8.219-4.59 13.698-8.382 15.893c-8.067 4.67-25.32-1.4-43.927-17.412a156.726 156.726 0 0 1-6.437-5.87c7.214-7.889 14.423-17.06 21.459-27.246c12.376-1.098 24.068-2.894 34.671-5.345a134.17 134.17 0 0 1 1.386 6.193ZM87.276 214.515c-7.882 2.783-14.16 2.863-17.955.675c-8.075-4.657-11.432-22.636-6.853-46.752a156.923 156.923 0 0 1 1.869-8.499c10.486 2.32 22.093 3.988 34.498 4.994c7.084 9.967 14.501 19.128 21.976 27.15a134.668 134.668 0 0 1-4.877 4.492c-9.933 8.682-19.886 14.842-28.658 17.94ZM50.35 144.747c-12.483-4.267-22.792-9.812-29.858-15.863c-6.35-5.437-9.555-10.836-9.555-15.216c0-9.322 13.897-21.212 37.076-29.293c2.813-.98 5.757-1.905 8.812-2.773c3.204 10.42 7.406 21.315 12.477 32.332c-5.137 11.18-9.399 22.249-12.634 32.792a134.718 134.718 0 0 1-6.318-1.979Zm12.378-84.26c-4.811-24.587-1.616-43.134 6.425-47.789c8.564-4.958 27.502 2.111 47.463 19.835a144.318 144.318 0 0 1 3.841 3.545c-7.438 7.987-14.787 17.08-21.808 26.988c-12.04 1.116-23.565 2.908-34.161 5.309a160.342 160.342 0 0 1-1.76-7.887Zm110.427 27.268a347.8 347.8 0 0 0-7.785-12.803c8.168 1.033 15.994 2.404 23.343 4.08c-2.206 7.072-4.956 14.465-8.193 22.045a381.151 381.151 0 0 0-7.365-13.322Zm-45.032-43.861c5.044 5.465 10.096 11.566 15.065 18.186a322.04 322.04 0 0 0-30.257-.006c4.974-6.559 10.069-12.652 15.192-18.18ZM82.802 87.83a323.167 323.167 0 0 0-7.227 13.238c-3.184-7.553-5.909-14.98-8.134-22.152c7.304-1.634 15.093-2.97 23.209-3.984a321.524 321.524 0 0 0-7.848 12.897Zm8.081 65.352c-8.385-.936-16.291-2.203-23.593-3.793c2.26-7.3 5.045-14.885 8.298-22.6a321.187 321.187 0 0 0 7.257 13.246c2.594 4.48 5.28 8.868 8.038 13.147Zm37.542 31.03c-5.184-5.592-10.354-11.779-15.403-18.433c4.902.192 9.899.29 14.978.29c5.218 0 10.376-.117 15.453-.343c-4.985 6.774-10.018 12.97-15.028 18.486Zm52.198-57.817c3.422 7.8 6.306 15.345 8.596 22.52c-7.422 1.694-15.436 3.058-23.88 4.071a382.417 382.417 0 0 0 7.859-13.026a347.403 347.403 0 0 0 7.425-13.565Zm-16.898 8.101a358.557 358.557 0 0 1-12.281 19.815a329.4 329.4 0 0 1-23.444.823c-7.967 0-15.716-.248-23.178-.732a310.202 310.202 0 0 1-12.513-19.846h.001a307.41 307.41 0 0 1-10.923-20.627a310.278 310.278 0 0 1 10.89-20.637l-.001.001a307.318 307.318 0 0 1 12.413-19.761c7.613-.576 15.42-.876 23.31-.876H128c7.926 0 15.743.303 23.354.883a329.357 329.357 0 0 1 12.335 19.695a358.489 358.489 0 0 1 11.036 20.54a329.472 329.472 0 0 1-11 20.722Zm22.56-122.124c8.572 4.944 11.906 24.881 6.52 51.026c-.344 1.668-.73 3.367-1.15 5.09c-10.622-2.452-22.155-4.275-34.23-5.408c-7.034-10.017-14.323-19.124-21.64-27.008a160.789 160.789 0 0 1 5.888-5.4c18.9-16.447 36.564-22.941 44.612-18.3ZM128 90.808c12.625 0 22.86 10.235 22.86 22.86s-10.235 22.86-22.86 22.86s-22.86-10.235-22.86-22.86s10.235-22.86 22.86-22.86Z"></path></svg>

================
File: src/components/auth/LoginForm.tsx
================
import React, { useState, useEffect } from 'react';
import { Link as RouterLink } from 'react-router-dom';
import { useAuth } from '../../hooks/useAuth';
import {
  Avatar,
  Button,
  TextField,
  Link,
  Grid,
  Box,
  Typography,
  Container,
  Paper,
  Alert,
  CircularProgress
} from '@mui/material';
import { LockOutlined } from '@mui/icons-material';

const LoginForm: React.FC = () => {
  const [email, setEmail] = useState('');
  const [password, setPassword] = useState('');
  const [formError, setFormError] = useState('');
  
  const { login, error, isLoading, clearError } = useAuth();
  
  // Clear API errors when component unmounts
  useEffect(() => {
    return () => {
      clearError();
    };
  }, [clearError]);
  
  // Update local error message when API error changes
  useEffect(() => {
    if (error) {
      setFormError(error);
    }
  }, [error]);
  
  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    
    // Form validation
    if (!email.trim()) {
      setFormError('Email-ul este obligatoriu');
      return;
    }
    
    if (!password) {
      setFormError('Parola este obligatorie');
      return;
    }
    
    // Clear previous errors
    setFormError('');
    
    // Attempt login
    await login({ email, password });
  };
  
  return (
    <Container component="main" maxWidth="xs">
      <Paper elevation={3} sx={{ mt: 8, p: 4, display: 'flex', flexDirection: 'column', alignItems: 'center' }}>
        <Avatar sx={{ m: 1, bgcolor: 'secondary.main' }}>
          <LockOutlined />
        </Avatar>
        
        <Typography component="h1" variant="h5">
          Conectare
        </Typography>
        
        {formError && (
          <Alert severity="error" sx={{ width: '100%', mt: 2 }}>
            {formError}
          </Alert>
        )}
        
        <Box component="form" onSubmit={handleSubmit} sx={{ mt: 1, width: '100%' }}>
          <TextField
            margin="normal"
            required
            fullWidth
            id="email"
            label="Adresă de Email"
            name="email"
            autoComplete="email"
            autoFocus
            value={email}
            onChange={(e) => setEmail(e.target.value)}
            disabled={isLoading}
          />
          
          <TextField
            margin="normal"
            required
            fullWidth
            name="password"
            label="Parolă"
            type="password"
            id="password"
            autoComplete="current-password"
            value={password}
            onChange={(e) => setPassword(e.target.value)}
            disabled={isLoading}
          />
          
          <Button
            type="submit"
            fullWidth
            variant="contained"
            sx={{ mt: 3, mb: 2, py: 1.5 }}
            disabled={isLoading}
          >
            {isLoading ? <CircularProgress size={24} /> : 'Conectare'}
          </Button>
          
          <Grid container justifyContent="flex-end">
            <Grid item>
              <Link component={RouterLink} to="/register" variant="body2">
                {"Nu ai un cont? Înregistrează-te"}
              </Link>
            </Grid>
          </Grid>
        </Box>
      </Paper>
    </Container>
  );
};

export default LoginForm;

================
File: src/components/auth/RegisterForm.tsx
================
import React, { useState, useEffect } from 'react';
import { Link as RouterLink } from 'react-router-dom';
import { useAuth } from '../../hooks/useAuth';
import { CountryEnum } from '../../types';
import {
  Avatar,
  Button,
  TextField,
  FormControl,
  InputLabel,
  Select,
  MenuItem,
  Link,
  Grid,
  Box,
  Typography,
  Container,
  Paper,
  Alert,
  CircularProgress
} from '@mui/material';
import { PersonAddOutlined } from '@mui/icons-material';

const RegisterForm: React.FC = () => {
  const [email, setEmail] = useState('');
  const [password, setPassword] = useState('');
  const [confirmPassword, setConfirmPassword] = useState('');
  const [firstName, setFirstName] = useState('');
  const [lastName, setLastName] = useState('');
  const [country, setCountry] = useState<CountryEnum>(CountryEnum.RO);
  const [formError, setFormError] = useState('');
  const [successMessage, setSuccessMessage] = useState('');
  
  const { register, error, isLoading, clearError } = useAuth();
  
  // Clear API errors when component unmounts
  useEffect(() => {
    return () => {
      clearError();
    };
  }, [clearError]);
  
  // Update local error message when API error changes
  useEffect(() => {
    if (error) {
      setFormError(error);
      setSuccessMessage('');
    }
  }, [error]);
  
  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    
    // Clear previous messages
    setFormError('');
    setSuccessMessage('');
    
    // Form validation
    if (!email.trim() || !password || !firstName.trim() || !lastName.trim()) {
      setFormError('Toate câmpurile sunt obligatorii');
      return;
    }
    
    if (password !== confirmPassword) {
      setFormError('Parolele nu se potrivesc');
      return;
    }
    
    if (password.length < 8) {
      setFormError('Parola trebuie să aibă cel puțin 8 caractere');
      return;
    }
    
    // Attempt registration
    const success = await register({
      email,
      password,
      firstName,
      lastName,
      country
    });
    
    if (success) {
      setSuccessMessage('Înregistrare reușită! Acum vă puteți conecta.');
      // Reset form
      setEmail('');
      setPassword('');
      setConfirmPassword('');
      setFirstName('');
      setLastName('');
    }
  };
  
  return (
    <Container component="main" maxWidth="xs">
      <Paper elevation={3} sx={{ mt: 8, p: 4, display: 'flex', flexDirection: 'column', alignItems: 'center' }}>
        <Avatar sx={{ m: 1, bgcolor: 'secondary.main' }}>
          <PersonAddOutlined />
        </Avatar>
        
        <Typography component="h1" variant="h5">
          Creați un cont
        </Typography>
        
        {formError && (
          <Alert severity="error" sx={{ width: '100%', mt: 2 }}>
            {formError}
          </Alert>
        )}
        
        {successMessage && (
          <Alert severity="success" sx={{ width: '100%', mt: 2 }}>
            {successMessage}
          </Alert>
        )}
        
        <Box component="form" onSubmit={handleSubmit} sx={{ mt: 3, width: '100%' }}>
          <Grid container spacing={2}>
            <Grid item xs={12}>
              <TextField
                required
                fullWidth
                id="email"
                label="Adresă de Email"
                name="email"
                autoComplete="email"
                value={email}
                onChange={(e) => setEmail(e.target.value)}
                disabled={isLoading}
              />
            </Grid>
            
            <Grid item xs={12} sm={6}>
              <TextField
                required
                fullWidth
                id="firstName"
                label="Prenume"
                name="firstName"
                autoComplete="given-name"
                value={firstName}
                onChange={(e) => setFirstName(e.target.value)}
                disabled={isLoading}
              />
            </Grid>
            
            <Grid item xs={12} sm={6}>
              <TextField
                required
                fullWidth
                id="lastName"
                label="Nume"
                name="lastName"
                autoComplete="family-name"
                value={lastName}
                onChange={(e) => setLastName(e.target.value)}
                disabled={isLoading}
              />
            </Grid>
            
            <Grid item xs={12}>
              <FormControl fullWidth>
                <InputLabel id="country-label">Țară</InputLabel>
                <Select
                  labelId="country-label"
                  id="country"
                  value={country}
                  label="Țară"
                  onChange={(e) => setCountry(e.target.value as CountryEnum)}
                  disabled={isLoading}
                >
                  <MenuItem value={CountryEnum.RO}>România</MenuItem>
                  <MenuItem value={CountryEnum.MD}>Moldova</MenuItem>
                </Select>
              </FormControl>
            </Grid>
            
            <Grid item xs={12}>
              <TextField
                required
                fullWidth
                name="password"
                label="Parolă"
                type="password"
                id="password"
                autoComplete="new-password"
                value={password}
                onChange={(e) => setPassword(e.target.value)}
                disabled={isLoading}
                inputProps={{ minLength: 8 }}
                helperText="Parola trebuie să aibă cel puțin 8 caractere"
              />
            </Grid>
            
            <Grid item xs={12}>
              <TextField
                required
                fullWidth
                name="confirmPassword"
                label="Confirmă Parola"
                type="password"
                id="confirmPassword"
                value={confirmPassword}
                onChange={(e) => setConfirmPassword(e.target.value)}
                disabled={isLoading}
              />
            </Grid>
          </Grid>
          
          <Button
            type="submit"
            fullWidth
            variant="contained"
            sx={{ mt: 3, mb: 2, py: 1.5 }}
            disabled={isLoading}
          >
            {isLoading ? <CircularProgress size={24} /> : 'Înregistrare'}
          </Button>
          
          <Grid container justifyContent="flex-end">
            <Grid item>
              <Link component={RouterLink} to="/login" variant="body2">
                Aveți deja un cont? Conectare
              </Link>
            </Grid>
          </Grid>
        </Box>
      </Paper>
    </Container>
  );
};

export default RegisterForm;

================
File: src/components/common/Navbar.tsx
================
// src/components/common/Navbar.tsx
import React, { useState } from 'react';
import { Link as RouterLink, useNavigate, useLocation } from 'react-router-dom';
import { useAuth } from '../../hooks/useAuth';
import {
  AppBar,
  Toolbar,
  Typography,
  Button,
  IconButton,
  Menu,
  MenuItem,
  Avatar,
  Box,
  Drawer,
  List,
  ListItem,
  ListItemButton,
  ListItemIcon,
  ListItemText,
  Divider,
  Collapse,
  useMediaQuery,
  useTheme
} from '@mui/material';
import {
  Menu as MenuIcon,
  AccountCircle,
  Dashboard,
  Event,
  Home,
  Login,
  Logout,
  Person,
  PersonAdd,
  ExpandLess,
  ExpandMore,
  AdminPanelSettings,
  Spa,
  Schedule
} from '@mui/icons-material';

const Navbar: React.FC = () => {
  const { isAuthenticated, user, logout } = useAuth();
  const navigate = useNavigate();
  const location = useLocation();
  const theme = useTheme();
  const isMobile = useMediaQuery(theme.breakpoints.down('sm'));
  
  const [anchorEl, setAnchorEl] = useState<null | HTMLElement>(null);
  const [drawerOpen, setDrawerOpen] = useState(false);
  const [adminMenuOpen, setAdminMenuOpen] = useState(false);
  
  // Check if user has admin role
  const isAdmin = user?.roles && user.roles.includes('ROLE_ADMIN');
  
  const handleMenu = (event: React.MouseEvent<HTMLElement>) => {
    setAnchorEl(event.currentTarget);
  };

  const handleClose = () => {
    setAnchorEl(null);
  };
  
  const handleDrawerToggle = () => {
    setDrawerOpen(!drawerOpen);
  };
  
  const toggleAdminMenu = () => {
    setAdminMenuOpen(!adminMenuOpen);
  };

  const handleLogout = async () => {
    handleClose();
    await logout();
    navigate('/');
  };
  
  const handleNavigation = (path: string) => {
    navigate(path);
    handleClose();
    setDrawerOpen(false);
  };
  
  // Drawer content
  const drawerContent = (
    <Box sx={{ width: 250 }} role="presentation">
      <List>
        <ListItem>
          <Typography variant="h6" color="primary">
            Dasha's Nails
          </Typography>
        </ListItem>
        <Divider />
        
        <ListItem>
          <ListItemButton onClick={() => handleNavigation('/')}>
            <ListItemIcon>
              <Home />
            </ListItemIcon>
            <ListItemText primary="Prezentare" />
          </ListItemButton>
        </ListItem>
        
        {isAuthenticated ? (
          <>
            <ListItem>
              <ListItemButton onClick={() => handleNavigation('/dashboard')}>
                <ListItemIcon>
                  <Dashboard />
                </ListItemIcon>
                <ListItemText primary="Panou" />
              </ListItemButton>
            </ListItem>
            
            <ListItem>
              <ListItemButton onClick={() => handleNavigation('/appointments')}>
                <ListItemIcon>
                  <Event />
                </ListItemIcon>
                <ListItemText primary="Programările mele" />
              </ListItemButton>
            </ListItem>
            
            <ListItem>
              <ListItemButton onClick={() => handleNavigation('/appointments/new')}>
                <ListItemIcon>
                  <Schedule />
                </ListItemIcon>
                <ListItemText primary="Programare nouă" />
              </ListItemButton>
            </ListItem>
            
            <ListItem>
              <ListItemButton onClick={() => handleNavigation('/profile')}>
                <ListItemIcon>
                  <Person />
                </ListItemIcon>
                <ListItemText primary="Profil" />
              </ListItemButton>
            </ListItem>
            
            {isAdmin && (
              <>
                <ListItem>
                  <ListItemButton onClick={toggleAdminMenu}>
                    <ListItemIcon>
                      <AdminPanelSettings />
                    </ListItemIcon>
                    <ListItemText primary="Administrare" />
                    {adminMenuOpen ? <ExpandLess /> : <ExpandMore />}
                  </ListItemButton>
                </ListItem>
                <Collapse in={adminMenuOpen} timeout="auto" unmountOnExit>
                  <List component="div" disablePadding>
                    <ListItemButton 
                      sx={{ pl: 4 }}
                      onClick={() => handleNavigation('/admin/services')}
                    >
                      <ListItemIcon>
                        <Spa />
                      </ListItemIcon>
                      <ListItemText primary="Servicii" />
                    </ListItemButton>
                  </List>
                </Collapse>
              </>
            )}
            
            <Divider />
            
            <ListItem>
              <ListItemButton onClick={handleLogout}>
                <ListItemIcon>
                  <Logout />
                </ListItemIcon>
                <ListItemText primary="Deconectare" />
              </ListItemButton>
            </ListItem>
          </>
        ) : (
          <>
            <ListItem>
              <ListItemButton onClick={() => handleNavigation('/login')}>
                <ListItemIcon>
                  <Login />
                </ListItemIcon>
                <ListItemText primary="Conectare" />
              </ListItemButton>
            </ListItem>
            
            <ListItem>
              <ListItemButton onClick={() => handleNavigation('/register')}>
                <ListItemIcon>
                  <PersonAdd />
                </ListItemIcon>
                <ListItemText primary="Înregistrare" />
              </ListItemButton>
            </ListItem>
          </>
        )}
      </List>
    </Box>
  );

  return (
    <>
      <AppBar position="static">
        <Toolbar>
          {isMobile && (
            <IconButton
              edge="start"
              color="inherit"
              aria-label="menu"
              onClick={handleDrawerToggle}
              sx={{ mr: 2 }}
            >
              <MenuIcon />
            </IconButton>
          )}
          
          <Typography
            variant="h6"
            component={RouterLink}
            to="/"
            sx={{ 
              flexGrow: 1, 
              textDecoration: 'none', 
              color: 'inherit',
              fontWeight: 800
            }}
          >
            Dasha's Nails
          </Typography>
          
          {!isMobile && (
            <Box sx={{ display: 'flex' }}>
              <Button 
                color="inherit" 
                component={RouterLink} 
                to="/"
              >
                Prezentare
              </Button>
              
              {isAuthenticated ? (
                <>
                  <Button 
                    color="inherit" 
                    component={RouterLink} 
                    to="/dashboard"
                  >
                    Panou
                  </Button>
                  
                  <Button 
                    color="inherit" 
                    component={RouterLink} 
                    to="/appointments"
                  >
                    Programări
                  </Button>
                  
                  {isAdmin && (
                    <Button
                      color="inherit"
                      onClick={handleMenu}
                      endIcon={<ExpandMore />}
                    >
                      Admin
                    </Button>
                  )}
                </>
              ) : null}
            </Box>
          )}
          
          {isAuthenticated ? (
            <div>
              <IconButton
                aria-label="account of current user"
                aria-controls="menu-appbar"
                aria-haspopup="true"
                onClick={handleMenu}
                color="inherit"
              >
                {user?.firstName ? (
                  <Avatar sx={{ width: 32, height: 32, bgcolor: 'secondary.main' }}>
                    {user.firstName[0]}
                  </Avatar>
                ) : (
                  <AccountCircle />
                )}
              </IconButton>
              
              <Menu
                id="menu-appbar"
                anchorEl={anchorEl}
                anchorOrigin={{
                  vertical: 'bottom',
                  horizontal: 'right',
                }}
                keepMounted
                transformOrigin={{
                  vertical: 'top',
                  horizontal: 'right',
                }}
                open={Boolean(anchorEl)}
                onClose={handleClose}
              >
                <MenuItem onClick={() => handleNavigation('/profile')}>
                  Profil
                </MenuItem>
                
                {isAdmin && !isMobile && (
                  <>
                    <Divider />
                    <MenuItem 
                      onClick={() => handleNavigation('/admin/services')}
                    >
                      Gestionare Servicii
                    </MenuItem>
                  </>
                )}
                
                <Divider />
                <MenuItem onClick={handleLogout}>Deconectare</MenuItem>
              </Menu>
            </div>
          ) : (
            !isMobile && (
              <div>
                <Button 
                  color="inherit" 
                  component={RouterLink} 
                  to="/login"
                >
                  Conectare
                </Button>
                <Button 
                  color="inherit" 
                  component={RouterLink} 
                  to="/register"
                >
                  Înregistrează-te
                </Button>
              </div>
            )
          )}
        </Toolbar>
      </AppBar>
      
      <Drawer
        anchor="left"
        open={drawerOpen}
        onClose={handleDrawerToggle}
      >
        {drawerContent}
      </Drawer>
    </>
  );
};

export default Navbar

================
File: src/components/common/ProtectedRoute.tsx
================
import React from 'react';
import { Navigate, useLocation } from 'react-router-dom';
import { useAuth } from '../../hooks/useAuth';
import { CircularProgress, Box } from '@mui/material';

interface ProtectedRouteProps {
  children: React.ReactNode;
}

const ProtectedRoute: React.FC<ProtectedRouteProps> = ({ children }) => {
  const { isAuthenticated, isLoading } = useAuth();
  const location = useLocation();

  if (isLoading) {
    return (
      <Box sx={{ display: 'flex', justifyContent: 'center', alignItems: 'center', height: '100vh' }}>
        <CircularProgress />
      </Box>
    );
  }

  if (!isAuthenticated) {
    return <Navigate to="/login" state={{ from: location }} replace />;
  }

  return <>{children}</>;
};

export default ProtectedRoute;

================
File: src/hooks/useAppointments.ts
================
import { useDispatch, useSelector } from 'react-redux';
import { 
  fetchClientAppointments, 
  fetchProviderAppointments,
  fetchAppointmentById,
  createNewAppointment,
  updateExistingAppointment,
  cancelExistingAppointment,
  fetchAvailableTimeSlots,
  fetchServices,
  resetAppointmentError,
  resetCurrentAppointment,
  clearAvailableTimeSlots
} from '../store/appointmentSlice';
import { RootState, AppDispatch } from '../store/store';
import { 
  CreateAppointmentRequest, 
  UpdateAppointmentRequest 
} from '../types/appointment';

export const useAppointments = () => {
  const dispatch = useDispatch<AppDispatch>();
  const { 
    appointments, 
    currentAppointment, 
    services,
    availableTimeSlots,
    isLoading, 
    error 
  } = useSelector((state: RootState) => state.appointments);
  
  // Client appointments
  const getClientAppointments = async (clientId: number) => {
    try {
      await dispatch(fetchClientAppointments(clientId)).unwrap();
      return true;
    } catch (error) {
      return false;
    }
  };
  
  // Provider appointments
  const getProviderAppointments = async (providerId: number) => {
    try {
      await dispatch(fetchProviderAppointments(providerId)).unwrap();
      return true;
    } catch (error) {
      return false;
    }
  };
  
  // Get specific appointment
  const getAppointment = async (id: number) => {
    try {
      await dispatch(fetchAppointmentById(id)).unwrap();
      return true;
    } catch (error) {
      return false;
    }
  };
  
  // Create appointment
  const createAppointment = async (request: CreateAppointmentRequest) => {
    try {
      const result = await dispatch(createNewAppointment(request)).unwrap();
      return result;
    } catch (error) {
      return null;
    }
  };
  
  // Update appointment
  const updateAppointment = async (id: number, request: UpdateAppointmentRequest) => {
    try {
      const result = await dispatch(updateExistingAppointment({ id, request })).unwrap();
      return result;
    } catch (error) {
      return null;
    }
  };
  
  // Cancel appointment
  const cancelAppointment = async (id: number) => {
    try {
      const result = await dispatch(cancelExistingAppointment(id)).unwrap();
      return result;
    } catch (error) {
      return null;
    }
  };
  
  // Get available time slots
  const getAvailableTimeSlots = async (providerId: number, date: string) => {
    try {
      await dispatch(fetchAvailableTimeSlots({ providerId, date })).unwrap();
      return true;
    } catch (error) {
      return false;
    }
  };
  
  // Get services
  const getServices = async (activeOnly: boolean = true) => {
    try {
      await dispatch(fetchServices(activeOnly)).unwrap();
      return true;
    } catch (error) {
      return false;
    }
  };
  
  // Reset current appointment
  const resetAppointment = () => {
    dispatch(resetCurrentAppointment());
  };
  
  // Clear available time slots
  const clearTimeSlots = () => {
    dispatch(clearAvailableTimeSlots());
  };
  
  // Clear error
  const clearError = () => {
    dispatch(resetAppointmentError());
  };
  
  return {
    appointments,
    currentAppointment,
    services,
    availableTimeSlots,
    isLoading,
    error,
    getClientAppointments,
    getProviderAppointments,
    getAppointment,
    createAppointment,
    updateAppointment,
    cancelAppointment,
    getAvailableTimeSlots,
    getServices,
    resetAppointment,
    clearTimeSlots,
    clearError
  };
};

================
File: src/hooks/useAuth.ts
================
import { useEffect } from 'react';
import { useDispatch, useSelector } from 'react-redux';
import { useNavigate } from 'react-router-dom';
import { 
  login as loginAction, 
  register as registerAction,
  logout as logoutAction,
  getCurrentUser, 
  resetAuthError
} from '../store/authSlice';
import { RootState, AppDispatch } from '../store/store';
import { LoginRequest, RegisterRequest } from '../types';
import { getAccessToken } from '../utils/tokenUtils';

export const useAuth = () => {
  const dispatch = useDispatch<AppDispatch>();
  const navigate = useNavigate();
  const auth = useSelector((state: RootState) => state.auth);
  
  // Check authentication status on mount
  useEffect(() => {
    const token = getAccessToken();
    
    if (token && !auth.user) {
      // If we have a token but no user data, try to fetch the user
      dispatch(getCurrentUser());
    }
  }, [dispatch, auth.user]);
  
  // Login function
  const login = async (credentials: LoginRequest) => {
    try {
      await dispatch(loginAction(credentials)).unwrap();
      navigate('/dashboard');
      return true;
    } catch (error) {
      return false;
    }
  };
  
  // Register function
  const register = async (userData: RegisterRequest) => {
    try {
      await dispatch(registerAction(userData)).unwrap();
      return true;
    } catch (error) {
      return false;
    }
  };
  
  // Logout function
  const logout = async () => {
    await dispatch(logoutAction());
    navigate('/');
  };
  
  // Clear authentication errors
  const clearError = () => {
    dispatch(resetAuthError());
  };
  
  return {
    user: auth.user,
    isAuthenticated: auth.isAuthenticated,
    isLoading: auth.isLoading,
    error: auth.error,
    login,
    register,
    logout,
    clearError
  };
};

================
File: src/main.tsx
================
import { StrictMode } from 'react'
import { createRoot } from 'react-dom/client'
import './index.css'
import App from './App.tsx'

const rootElement = document.getElementById('root');

if (!rootElement) {
  console.error('Root element not found');
} else {
  const root = createRoot(rootElement);
  root.render(
    <StrictMode>
      <App />
    </StrictMode>
  );
  console.log('React app mounted successfully');
}

================
File: src/pages/AppointmentDetailsPage.tsx
================
// src/pages/AppointmentDetailsPage.tsx
import React, { useEffect } from 'react';
import { useParams, useNavigate } from 'react-router-dom';
import { useAppointments } from '../hooks/useAppointments';
import { format, parseISO } from 'date-fns';
import { AppointmentStatusEnum } from '../types/appointment';
import {
  Container,
  Typography,
  Box,
  Paper,
  Grid,
  Button,
  Chip,
  Divider,
  CircularProgress,
  Alert,
  IconButton
} from '@mui/material';
import {
  ArrowBack as ArrowBackIcon,
  CalendarToday as CalendarIcon,
  AccessTime as TimeIcon,
  Person as PersonIcon,
  Edit as EditIcon,
  Cancel as CancelIcon
} from '@mui/icons-material';

const AppointmentDetailsPage: React.FC = () => {
  const { id } = useParams<{ id: string }>();
  const navigate = useNavigate();
  const { currentAppointment, getAppointment, cancelAppointment, isLoading, error } = useAppointments();
  
  useEffect(() => {
    if (id) {
      getAppointment(parseInt(id));
    }
  }, [id, getAppointment]);
  
  // Format date for display
  const formatDateTime = (dateTime: string) => {
    try {
      const parsedDate = parseISO(dateTime);
      return format(parsedDate, 'dd MMMM yyyy, HH:mm');
    } catch (error) {
      return dateTime;
    }
  };
  
  // Handle cancel appointment
  const handleCancelAppointment = async () => {
    if (!currentAppointment) return;
    
    if (window.confirm('Sunteți sigur că doriți să anulați această programare?')) {
      const result = await cancelAppointment(currentAppointment.id);
      if (result) {
        // Refresh the appointment data
        getAppointment(currentAppointment.id);
      }
    }
  };
  
  // Get status chip color
  const getStatusColor = (status: AppointmentStatusEnum) => {
    switch (status) {
      case AppointmentStatusEnum.PENDING:
        return 'warning';
      case AppointmentStatusEnum.CONFIRMED:
        return 'success';
      case AppointmentStatusEnum.CANCELLED:
        return 'error';
      case AppointmentStatusEnum.COMPLETED:
        return 'primary';
      case AppointmentStatusEnum.NO_SHOW:
        return 'error';
      default:
        return 'default';
    }
  };
  
  // Check if appointment can be cancelled or edited
  const canModify = currentAppointment && 
    (currentAppointment.status === AppointmentStatusEnum.PENDING || 
     currentAppointment.status === AppointmentStatusEnum.CONFIRMED);
  
  return (
    <Container maxWidth="md" sx={{ mt: 4, mb: 4 }}>
      <Box sx={{ mb: 3, display: 'flex', alignItems: 'center' }}>
        <IconButton 
          aria-label="back" 
          onClick={() => navigate('/appointments')}
          sx={{ mr: 2 }}
        >
          <ArrowBackIcon />
        </IconButton>
        <Typography variant="h4" component="h1">
          Detalii programare
        </Typography>
      </Box>
      
      {error && (
        <Alert severity="error" sx={{ mb: 3 }}>
          {error}
        </Alert>
      )}
      
      {isLoading ? (
        <Box sx={{ display: 'flex', justifyContent: 'center', p: 4 }}>
          <CircularProgress />
        </Box>
      ) : !currentAppointment ? (
        <Alert severity="warning">
          Nu s-au putut găsi detaliile programării.
        </Alert>
      ) : (
        <Paper sx={{ p: 3 }}>
          <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', mb: 3 }}>
            <Typography variant="h5">
              Programare #{currentAppointment.id}
            </Typography>
            <Chip 
              label={currentAppointment.status} 
              color={getStatusColor(currentAppointment.status)}
            />
          </Box>
          
          <Grid container spacing={3}>
            <Grid item xs={12} md={6}>
              <Box sx={{ display: 'flex', alignItems: 'center', mb: 2 }}>
                <CalendarIcon sx={{ mr: 2, color: 'primary.main' }} />
                <Box>
                  <Typography variant="body2" color="text.secondary">
                    Data și ora
                  </Typography>
                  <Typography variant="body1">
                    {formatDateTime(currentAppointment.startTime)}
                  </Typography>
                </Box>
              </Box>
              
              <Box sx={{ display: 'flex', alignItems: 'center', mb: 2 }}>
                <TimeIcon sx={{ mr: 2, color: 'primary.main' }} />
                <Box>
                  <Typography variant="body2" color="text.secondary">
                    Durată
                  </Typography>
                  <Typography variant="body1">
                    {Math.round(
                      (new Date(currentAppointment.endTime).getTime() - 
                      new Date(currentAppointment.startTime).getTime()) / 60000
                    )} minute
                  </Typography>
                </Box>
              </Box>
            </Grid>
            
            <Grid item xs={12} md={6}>
              <Box sx={{ display: 'flex', alignItems: 'center', mb: 2 }}>
                <PersonIcon sx={{ mr: 2, color: 'primary.main' }} />
                <Box>
                  <Typography variant="body2" color="text.secondary">
                    Specialist
                  </Typography>
                  <Typography variant="body1">
                    {currentAppointment.providerName}
                  </Typography>
                </Box>
              </Box>
            </Grid>
            
            <Grid item xs={12}>
              <Divider sx={{ my: 2 }} />
              <Typography variant="h6" gutterBottom>
                Servicii
              </Typography>
              
              {currentAppointment.services.map((service) => (
                <Box 
                  key={service.id}
                  sx={{ 
                    display: 'flex', 
                    justifyContent: 'space-between',
                    mb: 1
                  }}
                >
                  <Typography variant="body1">
                    {service.name} ({service.durationMinutes} min)
                  </Typography>
                  <Typography variant="body1">
                    {service.price} lei
                  </Typography>
                </Box>
              ))}
              
              <Box 
                sx={{ 
                  display: 'flex', 
                  justifyContent: 'space-between',
                  mt: 2,
                  pt: 2,
                  borderTop: '1px solid',
                  borderColor: 'divider'
                }}
              >
                <Typography variant="subtitle1" fontWeight="bold">
                  Total
                </Typography>
                <Typography variant="subtitle1" fontWeight="bold">
                  {currentAppointment.totalPrice} lei
                </Typography>
              </Box>
            </Grid>
            
            {currentAppointment.notes && (
              <Grid item xs={12}>
                <Divider sx={{ my: 2 }} />
                <Typography variant="h6" gutterBottom>
                  Note
                </Typography>
                <Typography variant="body1">
                  {currentAppointment.notes}
                </Typography>
              </Grid>
            )}
            
            {canModify && (
              <Grid item xs={12}>
                <Divider sx={{ my: 2 }} />
                <Box sx={{ display: 'flex', gap: 2, justifyContent: 'flex-end' }}>
                  <Button
                    variant="outlined"
                    startIcon={<EditIcon />}
                    onClick={() => navigate(`/appointments/edit/${currentAppointment.id}`)}
                  >
                    Modifică
                  </Button>
                  <Button
                    variant="outlined"
                    color="error"
                    startIcon={<CancelIcon />}
                    onClick={handleCancelAppointment}
                  >
                    Anulează
                  </Button>
                </Box>
              </Grid>
            )}
          </Grid>
        </Paper>
      )}
    </Container>
  )
}

export default AppointmentDetailsPage

================
File: src/pages/AppointmentsPage.tsx
================
// src/pages/AppointmentsPage.tsx
import React, { useEffect, useState } from 'react';
import { useAuth } from '../hooks/useAuth';
import { useAppointments } from '../hooks/useAppointments';
import { AppointmentStatusEnum } from '../types/appointment';
import { format, parseISO } from 'date-fns';
import {
  Container,
  Typography,
  Box,
  Paper,
  Tabs,
  Tab,
  Divider,
  List,
  ListItem,
  ListItemText,
  ListItemSecondaryAction,
  IconButton,
  Button,
  Chip,
  Dialog,
  DialogTitle,
  DialogContent,
  DialogContentText,
  DialogActions,
  CircularProgress,
  Alert,
  Grid
} from '@mui/material';
import { 
  CalendarToday as CalendarIcon,
  AccessTime as TimeIcon,
  Edit as EditIcon,
  Cancel as CancelIcon,
  Info as InfoIcon
} from '@mui/icons-material';

interface TabPanelProps {
  children?: React.ReactNode;
  index: number;
  value: number;
}

const TabPanel = (props: TabPanelProps) => {
  const { children, value, index, ...other } = props;

  return (
    <div
      role="tabpanel"
      hidden={value !== index}
      id={`appointment-tabpanel-${index}`}
      aria-labelledby={`appointment-tab-${index}`}
      {...other}
    >
      {value === index && (
        <Box sx={{ p: 3 }}>
          {children}
        </Box>
      )}
    </div>
  );
};

const AppointmentsPage: React.FC = () => {
  const { user } = useAuth();
  const { 
    appointments, 
    getClientAppointments, 
    cancelAppointment,
    isLoading, 
    error 
  } = useAppointments();
  
  const [tabValue, setTabValue] = useState(0);
  const [cancelDialogOpen, setCancelDialogOpen] = useState(false);
  const [selectedAppointmentId, setSelectedAppointmentId] = useState<number | null>(null);
  
  useEffect(() => {
    if (user?.id) {
      getClientAppointments(user.id);
    }
  // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [user?.id]); // Scoate getClientAppointments din dependențe
  
  const handleTabChange = (_event: React.SyntheticEvent, newValue: number) => {
    setTabValue(newValue);
  };
  
  // Filter appointments by status
  const upcomingAppointments = appointments.filter(
    apt => apt.status === AppointmentStatusEnum.PENDING || 
          apt.status === AppointmentStatusEnum.CONFIRMED
  );
  
  const pastAppointments = appointments.filter(
    apt => apt.status === AppointmentStatusEnum.COMPLETED ||
          apt.status === AppointmentStatusEnum.CANCELLED ||
          apt.status === AppointmentStatusEnum.NO_SHOW
  );
  
  // Format date for display
  const formatDateTime = (dateTime: string) => {
    try {
      const parsedDate = parseISO(dateTime);
      return format(parsedDate, 'dd MMM yyyy, HH:mm');
    } catch (error) {
      return dateTime; // Fallback to original string if parsing fails
    }
  };
  
  // Handle appointment cancellation
  const handleCancelClick = (id: number) => {
    setSelectedAppointmentId(id);
    setCancelDialogOpen(true);
  };
  
  const handleCancelConfirm = async () => {
    if (selectedAppointmentId) {
      await cancelAppointment(selectedAppointmentId);
      setCancelDialogOpen(false);
      setSelectedAppointmentId(null);
    }
  };
  
  const handleCancelDialogClose = () => {
    setCancelDialogOpen(false);
    setSelectedAppointmentId(null);
  };
  
  // Get status chip color
  const getStatusColor = (status: AppointmentStatusEnum) => {
    switch (status) {
      case AppointmentStatusEnum.PENDING:
        return 'warning';
      case AppointmentStatusEnum.CONFIRMED:
        return 'success';
      case AppointmentStatusEnum.CANCELLED:
        return 'error';
      case AppointmentStatusEnum.COMPLETED:
        return 'primary';
      case AppointmentStatusEnum.NO_SHOW:
        return 'error';
      default:
        return 'default';
    }
  };
  
  return (
    <Container maxWidth="md" sx={{ mt: 4, mb: 4 }}>
      <Typography variant="h4" component="h1" gutterBottom>
        Programările mele
      </Typography>

      {error && (
        <Alert severity="error" sx={{ mb: 2 }}>
          {error}
        </Alert>
      )}

      <Paper sx={{ width: '100%', mb: 2 }}>
        <Tabs
          value={tabValue}
          onChange={handleTabChange}
          indicatorColor="primary"
          textColor="primary"
          centered
        >
          <Tab label={`Programări viitoare (${upcomingAppointments.length})`} />
          <Tab label={`Istoric programări (${pastAppointments.length})`} />
        </Tabs>

        <Divider />

        {isLoading ? (
          <Box sx={{ display: 'flex', justifyContent: 'center', p: 4 }}>
            <CircularProgress />
          </Box>
        ) : (
          <>
            <TabPanel value={tabValue} index={0}>
              {upcomingAppointments.length > 0 ? (
                <List>
                  {upcomingAppointments.map((appointment) => (
                    <React.Fragment key={appointment.id}>
                      <ListItem alignItems="flex-start">
                        <Grid container spacing={2}>
                          <Grid item xs={12} sm={8}>
                            <Box sx={{ display: 'flex', alignItems: 'center', mb: 1 }}>
                              <CalendarIcon fontSize="small" sx={{ mr: 1, color: 'primary.main' }} />
                              <Typography variant="subtitle1">
                                {formatDateTime(appointment.startTime)}
                              </Typography>
                            </Box>
                            
                            <Box sx={{ display: 'flex', alignItems: 'center', mb: 1 }}>
                              <TimeIcon fontSize="small" sx={{ mr: 1, color: 'primary.main' }} />
                              <Typography variant="body2">
                                Durată: {
                                  Math.round(
                                    (new Date(appointment.endTime).getTime() - 
                                    new Date(appointment.startTime).getTime()) / 60000
                                  )
                                } minute
                              </Typography>
                            </Box>
                            
                            <Typography variant="subtitle2" gutterBottom>
                              Servicii:
                            </Typography>
                            <Box sx={{ ml: 2 }}>
                              {appointment.services.map((service) => (
                                <Typography key={service.id} variant="body2">
                                  • {service.name} ({service.durationMinutes} min) - {service.price} lei
                                </Typography>
                              ))}
                            </Box>
                            
                            {appointment.notes && (
                              <Box sx={{ mt: 1 }}>
                                <Typography variant="body2" color="text.secondary">
                                  Note: {appointment.notes}
                                </Typography>
                              </Box>
                            )}
                          </Grid>
                          
                          <Grid item xs={12} sm={4}>
                            <Box sx={{ display: 'flex', flexDirection: 'column', alignItems: 'flex-end' }}>
                              <Chip 
                                label={appointment.status} 
                                color={getStatusColor(appointment.status)}
                                size="small"
                                sx={{ mb: 2 }}
                              />
                              
                              <Typography variant="subtitle1" sx={{ mb: 2 }}>
                                Total: {appointment.totalPrice} lei
                              </Typography>
                              
                              <Button
                                variant="outlined"
                                color="primary"
                                size="small"
                                startIcon={<EditIcon />}
                                sx={{ mb: 1 }}
                                href={`/appointments/edit/${appointment.id}`}
                              >
                                Modifică
                              </Button>
                              
                              <Button
                                variant="outlined"
                                color="error"
                                size="small"
                                startIcon={<CancelIcon />}
                                onClick={() => handleCancelClick(appointment.id)}
                              >
                                Anulează
                              </Button>
                            </Box>
                          </Grid>
                        </Grid>
                      </ListItem>
                      <Divider component="li" />
                    </React.Fragment>
                  ))}
                </List>
              ) : (
                <Box sx={{ p: 4, textAlign: 'center' }}>
                  <Typography variant="body1" color="text.secondary">
                    Nu aveți programări viitoare
                  </Typography>
                  <Button
                    variant="contained"
                    color="primary"
                    sx={{ mt: 2 }}
                    href="/appointments/new"
                  >
                    Creați o programare nouă
                  </Button>
                </Box>
              )}
            </TabPanel>
            
            <TabPanel value={tabValue} index={1}>
              {pastAppointments.length > 0 ? (
                <List>
                  {pastAppointments.map((appointment) => (
                    <React.Fragment key={appointment.id}>
                      <ListItem alignItems="flex-start">
                        <ListItemText
                          primary={
                            <Box sx={{ display: 'flex', alignItems: 'center', justifyContent: 'space-between' }}>
                              <Typography variant="subtitle1">
                                {formatDateTime(appointment.startTime)}
                              </Typography>
                              <Chip 
                                label={appointment.status} 
                                color={getStatusColor(appointment.status)}
                                size="small"
                              />
                            </Box>
                          }
                          secondary={
                            <>
                              <Typography variant="body2" component="span" display="block">
                                Servicii: {appointment.services.map(s => s.name).join(', ')}
                              </Typography>
                              <Typography variant="body2" component="span" display="block">
                                Total: {appointment.totalPrice} lei
                              </Typography>
                            </>
                          }
                        />
                        <ListItemSecondaryAction>
                          <IconButton 
                            edge="end" 
                            aria-label="details"
                            href={`/appointments/${appointment.id}`}
                          >
                            <InfoIcon />
                          </IconButton>
                        </ListItemSecondaryAction>
                      </ListItem>
                      <Divider component="li" />
                    </React.Fragment>
                  ))}
                </List>
              ) : (
                <Box sx={{ p: 4, textAlign: 'center' }}>
                  <Typography variant="body1" color="text.secondary">
                    Nu aveți programări anterioare
                  </Typography>
                </Box>
              )}
            </TabPanel>
          </>
        )}
      </Paper>
      
      {/* Create new appointment button */}
      <Box sx={{ display: 'flex', justifyContent: 'center', mt: 4 }}>
        <Button
          variant="contained"
          color="primary"
          size="large"
          href="/appointments/new"
        >
          Programare nouă
        </Button>
      </Box>
      
      {/* Cancel appointment confirmation dialog */}
      <Dialog
        open={cancelDialogOpen}
        onClose={handleCancelDialogClose}
      >
        <DialogTitle>Confirmare anulare programare</DialogTitle>
        <DialogContent>
          <DialogContentText>
            Sunteți sigur că doriți să anulați această programare? Această acțiune nu poate fi anulată.
          </DialogContentText>
        </DialogContent>
        <DialogActions>
          <Button onClick={handleCancelDialogClose} color="primary">
            Renunță
          </Button>
          <Button onClick={handleCancelConfirm} color="error" autoFocus>
            Anulează programarea
          </Button>
        </DialogActions>
      </Dialog>
    </Container>
  )
}

export default  AppointmentsPage

================
File: src/pages/DashboardPage.tsx
================
import React from 'react';
import { useAuth } from '../hooks/useAuth';
import {
  Container,
  Typography,
  Box,
  Grid,
  Paper,
  Card,
  CardContent,
  CardHeader,
  Divider,
  Button,
  List,
  ListItem,
  ListItemText,
  ListItemAvatar,
  Avatar
} from '@mui/material';
import { 
  Event as EventIcon,
  Today as TodayIcon,
  History as HistoryIcon,
  Add as AddIcon
} from '@mui/icons-material';

const DashboardPage: React.FC = () => {
  const { user } = useAuth();
  
  // This would typically come from an API call
  const upcomingAppointments = [
    {
      id: 1,
      service: 'Unghii simple',
      date: '2025-03-25',
      time: '10:00 AM',
      provider: 'Daria'
    },
    {
      id: 2,
      service: 'Unghii gel',
      date: '2025-04-01',
      time: '2:30 PM',
      provider: 'Daria'
    }
  ];
  
  return (
    <Container maxWidth="lg" sx={{ mt: 4, mb: 4 }}>
      <Box sx={{ mb: 4 }}>
        <Typography variant="h4" component="h1" gutterBottom>
          Panou
        </Typography>
        <Typography variant="subtitle1" color="text.secondary">
          Bine ati revenit, {user?.firstName || 'Guest'}!
        </Typography>
      </Box>
      
      <Grid container spacing={3}>
        {/* Summary Cards */}
        <Grid item xs={12} md={4}>
          <Card sx={{ height: '100%' }}>
            <CardHeader title="Urmeaza" />
            <CardContent>
              <Box sx={{ display: 'flex', alignItems: 'center' }}>
                <Avatar sx={{ bgcolor: 'primary.main', mr: 2 }}>
                  <TodayIcon />
                </Avatar>
                <Typography variant="h4">{upcomingAppointments.length}</Typography>
              </Box>
              <Typography variant="body2" color="text.secondary" sx={{ mt: 1 }}>
                Aveti {upcomingAppointments.length} programari
              </Typography>
            </CardContent>
          </Card>
        </Grid>
        
        <Grid item xs={12} md={4}>
          <Card sx={{ height: '100%' }}>
            <CardHeader title="Istoric" />
            <CardContent>
              <Box sx={{ display: 'flex', alignItems: 'center' }}>
                <Avatar sx={{ bgcolor: 'secondary.main', mr: 2 }}>
                  <HistoryIcon />
                </Avatar>
                <Typography variant="h4">0</Typography>
              </Box>
              <Typography variant="body2" color="text.secondary" sx={{ mt: 1 }}>
                Ati avut 0 programari luna aceasta
              </Typography>
            </CardContent>
          </Card>
        </Grid>
        
        <Grid item xs={12} md={4}>
          <Card sx={{ height: '100%' }}>
            <CardHeader title="Actiuni rapide" />
            <CardContent>
              <Button 
                variant="contained" 
                startIcon={<AddIcon />}
                fullWidth
                sx={{ mb: 2 }}
              >
                Faceti o programare
              </Button>
              <Button 
                variant="outlined"
                fullWidth
              >
                Vezi toate programarile
              </Button>
            </CardContent>
          </Card>
        </Grid>
        
        {/* Upcoming Appointments */}
        <Grid item xs={12}>
          <Paper sx={{ p: 2 }}>
            <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', mb: 2 }}>
              <Typography variant="h6" component="h2">
                Programari viitoare
              </Typography>
              <Button
                variant="text"
                color="primary"
                size="small"
              >
                Vezi tot
              </Button>
            </Box>
            <Divider sx={{ mb: 2 }} />
            
            {upcomingAppointments.length > 0 ? (
              <List sx={{ width: '100%' }}>
                {upcomingAppointments.map((appointment) => (
                  <React.Fragment key={appointment.id}>
                    <ListItem alignItems="flex-start">
                      <ListItemAvatar>
                        <Avatar sx={{ bgcolor: 'primary.main' }}>
                          <EventIcon />
                        </Avatar>
                      </ListItemAvatar>
                      <ListItemText
                        primary={appointment.service}
                        secondary={
                          <>
                            <Typography
                              component="span"
                              variant="body2"
                              color="text.primary"
                            >
                              {appointment.date} la {appointment.time}
                            </Typography>
                            {` — cu ${appointment.provider}`}
                          </>
                        }
                      />
                      <Box>
                        <Button size="small" color="primary">
                          Reprogramati
                        </Button>
                        <Button size="small" color="error">
                          Anulati
                        </Button>
                      </Box>
                    </ListItem>
                    <Divider variant="inset" component="li" />
                  </React.Fragment>
                ))}
              </List>
            ) : (
              <Box sx={{ py: 4, textAlign: 'center' }}>
                <Typography color="text.secondary">
                  Nu aveti programari in viitor
                </Typography>
                <Button
                  variant="contained"
                  color="primary"
                  startIcon={<AddIcon />}
                  sx={{ mt: 2 }}
                >
                  Faceti prima programare
                </Button>
              </Box>
            )}
          </Paper>
        </Grid>
      </Grid>
    </Container>
  );
};

export default DashboardPage;

================
File: src/pages/EditAppointmentPage.tsx
================
import React, { useEffect, useState } from 'react';
import { useParams, useNavigate } from 'react-router-dom';
import { useAuth } from '../hooks/useAuth';
import { useAppointments } from '../hooks/useAppointments';
import { Service, UpdateAppointmentRequest } from '../types/appointment';
import { format, parseISO, addDays } from 'date-fns';
import {
  Container,
  Typography,
  Box,
  Paper,
  Grid,
  Button,
  TextField,
  FormControlLabel,
  FormControl,
  RadioGroup,
  Radio,
  CircularProgress,
  Alert,
  IconButton,
  Divider,
  Card,
  CardContent,
  CardActionArea
} from '@mui/material';
import { DatePicker } from '@mui/x-date-pickers/DatePicker';
import { AdapterDateFns } from '@mui/x-date-pickers/AdapterDateFns';
import { LocalizationProvider } from '@mui/x-date-pickers/LocalizationProvider';
import {
  ArrowBack as ArrowBackIcon,
  CalendarToday as CalendarIcon,
  AccessTime as TimeIcon,
  CheckCircle as CheckCircleIcon,
  Save as SaveIcon
} from '@mui/icons-material';

const EditAppointmentPage: React.FC = () => {
  const { id } = useParams<{ id: string }>();
  const navigate = useNavigate();
  const { user } = useAuth();
  const { 
    currentAppointment, 
    services, 
    availableTimeSlots,
    getAppointment,
    getServices,
    getAvailableTimeSlots,
    updateAppointment,
    clearTimeSlots,
    isLoading, 
    error 
  } = useAppointments();
  
  // Form state
  const [selectedServices, setSelectedServices] = useState<Service[]>([]);
  const [selectedDate, setSelectedDate] = useState<Date | null>(null);
  const [selectedTimeSlot, setSelectedTimeSlot] = useState<string | null>(null);
  const [notes, setNotes] = useState('');
  const [formErrors, setFormErrors] = useState<{ [key: string]: string }>({});
  const [hasChanges, setHasChanges] = useState(false);
  
  // Computed values
  const totalDuration = selectedServices.reduce((sum, service) => sum + service.durationMinutes, 0);
  const totalPrice = selectedServices.reduce((sum, service) => sum + service.price, 0);
  
  // Fetch appointment and services on mount
  useEffect(() => {
    if (id) {
      getAppointment(parseInt(id));
      getServices(true);
    }
  // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [id]);
  
  // Initialize form with appointment data
  useEffect(() => {
    if (currentAppointment && services.length > 0) {
      // Find the service objects that match the appointment's services
      const appointmentServices = services.filter(service => 
        currentAppointment.services.some(s => s.id === service.id)
      );
      
      setSelectedServices(appointmentServices);
      
      // Parse the appointment start time to get the date
      const appointmentDate = parseISO(currentAppointment.startTime);
      setSelectedDate(appointmentDate);
      
      // Use the original start time string
      setSelectedTimeSlot(currentAppointment.startTime);
      
      // Set notes
      setNotes(currentAppointment.notes || '');
      
      // Fetch available time slots for the appointment date
      if (user?.id) {
        const formattedDate = format(appointmentDate, 'yyyy-MM-dd');
        console.log('Fetching timeslots for date:', formattedDate);
        // Use the appointment's provider ID
        const providerId = currentAppointment.providerId;
        getAvailableTimeSlots(providerId, formattedDate);
      }
    }
  // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [currentAppointment, services, user?.id]);
  
  // When date changes, fetch available time slots
  useEffect(() => {
    if (selectedDate && currentAppointment) {
      // Only if the date has changed from the original
      const originalDate = parseISO(currentAppointment.startTime);
      if (format(selectedDate, 'yyyy-MM-dd') !== format(originalDate, 'yyyy-MM-dd')) {
        // Clear previous time slots and selected time
        clearTimeSlots();
        setSelectedTimeSlot(null);
        
        // Format date for API
        const formattedDate = format(selectedDate, 'yyyy-MM-dd');
        console.log('Date changed, fetching timeslots for:', formattedDate);
        
        // Use the appointment's provider ID
        const providerId = currentAppointment.providerId;
        
        getAvailableTimeSlots(providerId, formattedDate);
        
        setHasChanges(true);
      }
    }
  // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [selectedDate, currentAppointment]);
  
  // Check for changes to track if form has been modified
  useEffect(() => {
    if (currentAppointment) {
      const servicesChanged = selectedServices.length !== currentAppointment.services.length ||
        !selectedServices.every(service => 
          currentAppointment.services.some(s => s.id === service.id)
        );
      
      const timeChanged = selectedTimeSlot !== currentAppointment.startTime;
      
      const notesChanged = notes !== (currentAppointment.notes || '');
      
      setHasChanges(servicesChanged || timeChanged || notesChanged);
    }
  }, [currentAppointment, selectedServices, selectedTimeSlot, notes]);
  
  // Handle service selection
  const handleServiceToggle = (service: Service) => {
    setSelectedServices((prev) => {
      const serviceIndex = prev.findIndex(s => s.id === service.id);
      if (serviceIndex === -1) {
        // Add service
        return [...prev, service];
      } else {
        // Remove service
        return prev.filter(s => s.id !== service.id);
      }
    });
  };
  
  // Handle time slot selection
  const handleTimeSlotSelect = (timeSlot: string) => {
    setSelectedTimeSlot(timeSlot);
  };
  
  // Handle form submission
  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    
    // Validate form
    const errors: { [key: string]: string } = {};
    
    if (selectedServices.length === 0) {
      errors.services = 'Selectați cel puțin un serviciu';
    }
    
    if (!selectedTimeSlot) {
      errors.time = 'Selectați o oră';
    }
    
    // If there are errors, show them and don't proceed
    if (Object.keys(errors).length > 0) {
      setFormErrors(errors);
      return;
    }
    
    // Clear any previous errors
    setFormErrors({});
    
    if (!currentAppointment || !selectedTimeSlot) return;
    
    // Prepare update data
    const updateData: UpdateAppointmentRequest = {
      id: currentAppointment.id,
      startTime: selectedTimeSlot,
      serviceIds: selectedServices.map(service => service.id),
      notes: notes.trim() || undefined
    };
    
    const result = await updateAppointment(currentAppointment.id, updateData);
    
    if (result) {
      navigate(`/appointments/${currentAppointment.id}`);
    }
  };
  
  // Format date for display
  const formatDateTime = (dateTime: string) => {
    try {
      const parsedDate = parseISO(dateTime);
      return format(parsedDate, 'HH:mm');
    } catch (error) {
      return dateTime;
    }
  };
  
  return (
    <Container maxWidth="md" sx={{ mt: 4, mb: 6 }}>
      <Box sx={{ mb: 3, display: 'flex', alignItems: 'center' }}>
        <IconButton 
          aria-label="back" 
          onClick={() => navigate(`/appointments/${id}`)}
          sx={{ mr: 2 }}
        >
          <ArrowBackIcon />
        </IconButton>
        <Typography variant="h4" component="h1">
          Modificare programare
        </Typography>
      </Box>
      
      {error && (
        <Alert severity="error" sx={{ mb: 3 }}>
          {error}
        </Alert>
      )}
      
      {isLoading && !currentAppointment ? (
        <Box sx={{ display: 'flex', justifyContent: 'center', p: 4 }}>
          <CircularProgress />
        </Box>
      ) : !currentAppointment ? (
        <Alert severity="warning">
          Nu s-au putut găsi detaliile programării.
        </Alert>
      ) : (
        <Paper sx={{ p: 3 }}>
          <form onSubmit={handleSubmit}>
            <Grid container spacing={4}>
              {/* Services selection */}
              <Grid item xs={12}>
                <Typography variant="h6" gutterBottom>
                  Servicii
                </Typography>
                
                {formErrors.services && (
                  <Alert severity="error" sx={{ mb: 2 }}>
                    {formErrors.services}
                  </Alert>
                )}
                
                <Grid container spacing={2}>
                  {services.map((service) => (
                    <Grid item xs={12} sm={6} md={4} key={service.id}>
                      <Card 
                        variant="outlined"
                        sx={{ 
                          height: '100%',
                          border: selectedServices.some(s => s.id === service.id) 
                            ? '2px solid' 
                            : '1px solid',
                          borderColor: selectedServices.some(s => s.id === service.id)
                            ? 'primary.main'
                            : 'divider'
                        }}
                      >
                        <CardActionArea 
                          onClick={() => handleServiceToggle(service)}
                          sx={{ height: '100%', display: 'flex', flexDirection: 'column', alignItems: 'stretch' }}
                        >
                          <CardContent sx={{ flexGrow: 1 }}>
                            <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'flex-start' }}>
                              <Typography variant="h6" component="div">
                                {service.name}
                              </Typography>
                              {selectedServices.some(s => s.id === service.id) && (
                                <CheckCircleIcon color="primary" />
                              )}
                            </Box>
                            
                            {service.description && (
                              <Typography variant="body2" color="text.secondary" sx={{ mt: 1 }}>
                                {service.description}
                              </Typography>
                            )}
                            
                            <Box sx={{ display: 'flex', justifyContent: 'space-between', mt: 2 }}>
                              <Typography variant="body2" color="text.secondary">
                                <TimeIcon fontSize="small" sx={{ verticalAlign: 'middle', mr: 0.5 }} />
                                {service.durationMinutes} min
                              </Typography>
                              <Typography variant="subtitle1">
                                {service.price} lei
                              </Typography>
                            </Box>
                          </CardContent>
                        </CardActionArea>
                      </Card>
                    </Grid>
                  ))}
                </Grid>
                
                {selectedServices.length > 0 && (
                  <Paper variant="outlined" sx={{ mt: 3, p: 2 }}>
                    <Typography variant="subtitle1" gutterBottom>
                      Servicii selectate:
                    </Typography>
                    {selectedServices.map((service) => (
                      <Box key={service.id} sx={{ display: 'flex', justifyContent: 'space-between', mb: 1 }}>
                        <Typography variant="body1">
                          {service.name} ({service.durationMinutes} min)
                        </Typography>
                        <Typography variant="body1">
                          {service.price} lei
                        </Typography>
                      </Box>
                    ))}
                    <Divider sx={{ my: 1 }} />
                    <Box sx={{ display: 'flex', justifyContent: 'space-between' }}>
                      <Typography variant="subtitle1">
                        Durată totală: {totalDuration} min
                      </Typography>
                      <Typography variant="subtitle1">
                        Total: {totalPrice} lei
                      </Typography>
                    </Box>
                  </Paper>
                )}
              </Grid>
              
              {/* Date and time selection */}
              <Grid item xs={12}>
                <Typography variant="h6" gutterBottom>
                  Data și ora
                </Typography>
                
                <Grid container spacing={3}>
                  <Grid item xs={12} md={6}>
                    <LocalizationProvider dateAdapter={AdapterDateFns}>
                      <DatePicker 
                        label="Data programării"
                        value={selectedDate}
                        onChange={(newDate) => setSelectedDate(newDate)}
                        disablePast
                        maxDate={addDays(new Date(), 30)}
                        slotProps={{ 
                          textField: { 
                            fullWidth: true,
                            error: !!formErrors.date,
                            helperText: formErrors.date
                          } 
                        }}
                      />
                    </LocalizationProvider>
                  </Grid>
                </Grid>
                
                <Typography variant="subtitle1" sx={{ mt: 3, mb: 2 }}>
                  Ore disponibile:
                </Typography>
                
                {isLoading && !availableTimeSlots.length ? (
                  <Box sx={{ display: 'flex', justifyContent: 'center', p: 2 }}>
                    <CircularProgress />
                  </Box>
                ) : availableTimeSlots.length === 0 ? (
                  <Alert severity="info">
                    {selectedDate && format(selectedDate, 'yyyy-MM-dd') !== format(parseISO(currentAppointment.startTime), 'yyyy-MM-dd')
                      ? 'Nu există ore disponibile pentru data selectată. Vă rugăm să selectați o altă dată.'
                      : 'Ora programării curente va fi păstrată. Selectați o altă dată pentru a vedea orele disponibile.'}
                  </Alert>
                ) : (
                  <>
                    {formErrors.time && (
                      <Alert severity="error" sx={{ mb: 2 }}>
                        {formErrors.time}
                      </Alert>
                    )}
                    
                    <FormControl component="fieldset">
                      <RadioGroup 
                        value={selectedTimeSlot || ''}
                        onChange={(e) => handleTimeSlotSelect(e.target.value)}
                      >
                        <Grid container spacing={2}>
                          {availableTimeSlots
                            .filter(slot => slot.available || slot.startTime === currentAppointment.startTime)
                            .map((timeSlot, index) => (
                              <Grid item xs={6} sm={4} md={3} key={index}>
                                <FormControlLabel
                                  value={timeSlot.startTime}
                                  control={<Radio />}
                                  label={formatDateTime(timeSlot.startTime)}
                                  sx={{
                                    display: 'flex',
                                    border: '1px solid',
                                    borderColor: 'divider',
                                    borderRadius: 1,
                                    p: 1,
                                    width: '100%',
                                    m: 0
                                  }}
                                />
                              </Grid>
                            ))}
                        </Grid>
                      </RadioGroup>
                    </FormControl>
                  </>
                )}
              </Grid>
              
              {/* Notes */}
              <Grid item xs={12}>
                <Typography variant="h6" gutterBottom>
                  Note (opțional)
                </Typography>
                <TextField
                  multiline
                  rows={3}
                  fullWidth
                  placeholder="Adăugați orice informații suplimentare pentru programarea dvs."
                  value={notes}
                  onChange={(e) => setNotes(e.target.value)}
                  inputProps={{ maxLength: 500 }}
                />
              </Grid>
              
              {/* Submit button */}
              <Grid item xs={12}>
                <Box sx={{ display: 'flex', justifyContent: 'flex-end', mt: 2 }}>
                  <Button
                    type="button"
                    variant="outlined"
                    onClick={() => navigate(`/appointments/${id}`)}
                    sx={{ mr: 2 }}
                  >
                    Anulează
                  </Button>
                  <Button
                    type="submit"
                    variant="contained"
                    color="primary"
                    startIcon={<SaveIcon />}
                    disabled={isLoading || !hasChanges}
                  >
                    {isLoading ? <CircularProgress size={24} /> : 'Salvează modificările'}
                  </Button>
                </Box>
              </Grid>
            </Grid>
          </form>
        </Paper>
      )}
    </Container>
  );
};

export default EditAppointmentPage;

================
File: src/pages/HomePage.tsx
================
import React from 'react';
import { useNavigate } from 'react-router-dom';
import { useAuth } from '../hooks/useAuth';
import {
  Box,
  Button,
  Container,
  Typography,
  Grid,
  Card,
  CardContent,
  CardActions,
  CardMedia,
  Stack
} from '@mui/material';
import { 
  EventAvailable, 
  CalendarToday, 
  AccessTime, 
  Notifications 
} from '@mui/icons-material';

const HomePage: React.FC = () => {
  const { isAuthenticated } = useAuth();
  const navigate = useNavigate();

  const handleGetStarted = () => {
    if (isAuthenticated) {
      navigate('/dashboard');
    } else {
      navigate('/register');
    }
  };

  return (
    <Box>
      {/* Hero Section */}
      <Box
        sx={{
          bgcolor: 'primary.main',
          color: 'white',
          py: 8,
          mb: 6
        }}
      >
        <Container maxWidth="lg">
          <Grid container spacing={4} alignItems="center">
            <Grid item xs={12} md={6}>
              <Typography variant="h3" component="h1" gutterBottom>
                Cele mai bune unghii vin la pachet cu cel mai bun serviciu de programări
              </Typography>
              <Typography variant="h6" paragraph>
                Rezervă serviciile tale pentru unghii online, gestionează-ți programul și primește reminder-uri. Platforma noastră face programarea simplă.
              </Typography>
              <Stack direction="row" spacing={2} sx={{ mt: 4 }}>
                <Button 
                  variant="contained" 
                  size="large" 
                  color="secondary"
                  onClick={handleGetStarted}
                >
                  Începe
                </Button>
                {!isAuthenticated && (
                  <Button 
                    variant="outlined" 
                    size="large" 
                    color="inherit"
                    onClick={() => navigate('/login')}
                  >
                    Conectare
                  </Button>
                )}
              </Stack>
            </Grid>
            <Grid item xs={12} md={6}>
              <Box
                component="img"
                src="/api/placeholder/600/400"
                alt="Programare salon de unghii"
                sx={{
                  width: '100%',
                  borderRadius: 2,
                  boxShadow: 3
                }}
              />
            </Grid>
          </Grid>
        </Container>
      </Box>

      {/* Features Section */}
      <Container maxWidth="lg" sx={{ mb: 8 }}>
        <Typography variant="h4" component="h2" align="center" gutterBottom>
          Caracteristicile Noastre
        </Typography>
        <Typography variant="subtitle1" align="center" color="text.secondary" paragraph>
          Tot ce ai nevoie pentru a-ți gestiona programările
        </Typography>

        <Grid container spacing={4} sx={{ mt: 4 }}>
          <Grid item xs={12} sm={6} md={3}>
            <Card sx={{ height: '100%' }}>
              <Box sx={{ p: 2, display: 'flex', justifyContent: 'center' }}>
                <EventAvailable fontSize="large" color="primary" />
              </Box>
              <CardContent>
                <Typography variant="h6" component="h3" align="center">
                  Rezervare Ușoară
                </Typography>
                <Typography variant="body2" color="text.secondary" align="center">
                  Programează întâlniri cu tehnicianul tău preferat de unghii în câteva secunde.
                </Typography>
              </CardContent>
            </Card>
          </Grid>

          <Grid item xs={12} sm={6} md={3}>
            <Card sx={{ height: '100%' }}>
              <Box sx={{ p: 2, display: 'flex', justifyContent: 'center' }}>
                <CalendarToday fontSize="large" color="primary" />
              </Box>
              <CardContent>
                <Typography variant="h6" component="h3" align="center">
                  Gestionează Calendarul
                </Typography>
                <Typography variant="body2" color="text.secondary" align="center">
                  Vizualizează și gestionează toate programările tale într-un singur loc.
                </Typography>
              </CardContent>
            </Card>
          </Grid>

          <Grid item xs={12} sm={6} md={3}>
            <Card sx={{ height: '100%' }}>
              <Box sx={{ p: 2, display: 'flex', justifyContent: 'center' }}>
                <AccessTime fontSize="large" color="primary" />
              </Box>
              <CardContent>
                <Typography variant="h6" component="h3" align="center">
                  Disponibilitate în Timp Real
                </Typography>
                <Typography variant="body2" color="text.secondary" align="center">
                  Vezi disponibilitatea în timp real a tehnicienilor și serviciilor.
                </Typography>
              </CardContent>
            </Card>
          </Grid>

          <Grid item xs={12} sm={6} md={3}>
            <Card sx={{ height: '100%' }}>
              <Box sx={{ p: 2, display: 'flex', justifyContent: 'center' }}>
                <Notifications fontSize="large" color="primary" />
              </Box>
              <CardContent>
                <Typography variant="h6" component="h3" align="center">
                  Reminder-uri
                </Typography>
                <Typography variant="body2" color="text.secondary" align="center">
                  Primește reminder-uri automate înainte de programare.
                </Typography>
              </CardContent>
            </Card>
          </Grid>
        </Grid>
      </Container>

      {/* CTA Section */}
      <Box sx={{ bgcolor: 'grey.100', py: 6 }}>
        <Container maxWidth="md">
          <Typography variant="h4" align="center" gutterBottom>
            Ești gata să simplifici programările la salonul de unghii?
          </Typography>
          <Typography variant="subtitle1" align="center" color="text.secondary" paragraph>
            Alătură-te miilor de clienți mulțumiți care se bucură deja de platforma noastră.
          </Typography>
          <Box sx={{ display: 'flex', justifyContent: 'center', mt: 4 }}>
            <Button 
              variant="contained" 
              size="large" 
              color="primary"
              onClick={handleGetStarted}
            >
              {isAuthenticated ? 'Mergi la Panou de Control' : 'Înregistrează-te Acum'}
            </Button>
          </Box>
        </Container>
      </Box>
    </Box>
  );
};

export default HomePage;

================
File: src/pages/LoginPage.tsx
================
import React, { useEffect } from 'react';
import { useNavigate, useLocation } from 'react-router-dom';
import { Container } from '@mui/material';
import LoginForm from '../components/auth/LoginForm';
import { useAuth } from '../hooks/useAuth';

// Define a type for the location state
interface LocationState {
  from?: {
    pathname: string;
  };
}

const LoginPage: React.FC = () => {
  const { isAuthenticated } = useAuth();
  const navigate = useNavigate();
  const location = useLocation();
  
  // Get the desired redirect path from location state or default to dashboard
  const from = (location.state as LocationState)?.from?.pathname || '/dashboard';
  
  // Redirect if already authenticated
  useEffect(() => {
    if (isAuthenticated) {
      navigate(from, { replace: true });
    }
  }, [isAuthenticated, navigate, from]);
  
  return (
    <Container>
      <LoginForm />
    </Container>
  );
};

export default LoginPage;

================
File: src/pages/NewAppointmentPage.tsx
================
// src/pages/NewAppointmentPage.tsx
import React, { useEffect, useState } from 'react';
import { useNavigate } from 'react-router-dom';
import { useAuth } from '../hooks/useAuth';
import { useAppointments } from '../hooks/useAppointments';
import { Service } from '../types/appointment';
import { format, addDays, parseISO } from 'date-fns';
import {
  Container,
  Typography,
  Box,
  Paper,
  Stepper,
  Step,
  StepLabel,
  Grid,
  TextField,
  Button,
  FormControlLabel,
  Radio,
  RadioGroup,
  FormControl,
  CircularProgress,
  Alert,
  Card,
  CardContent,
  CardMedia,
  CardActionArea,
  Divider
} from '@mui/material';
import { DatePicker } from '@mui/x-date-pickers/DatePicker';
import { AdapterDateFns } from '@mui/x-date-pickers/AdapterDateFns';
import { LocalizationProvider } from '@mui/x-date-pickers/LocalizationProvider';
import { 
  CalendarMonth as CalendarIcon,
  AccessTime as TimeIcon,
  CheckCircle as CheckCircleIcon
} from '@mui/icons-material';

// Step components for the stepper
const steps = ['Selectare servicii', 'Selectare dată și oră', 'Confirmare'];

const NewAppointmentPage: React.FC = () => {
  const navigate = useNavigate();
  const { user } = useAuth();
  const { 
    services, 
    availableTimeSlots,
    getServices, 
    getAvailableTimeSlots,
    createAppointment,
    isLoading, 
    error,
    clearTimeSlots 
  } = useAppointments();
  
  // State for the appointment creation process
  const [activeStep, setActiveStep] = useState(0);
  const [selectedServices, setSelectedServices] = useState<Service[]>([]);
  const [selectedDate, setSelectedDate] = useState<Date | null>(null);
  const [selectedTimeSlot, setSelectedTimeSlot] = useState<string | null>(null);
  const [notes, setNotes] = useState('');
  const [formErrors, setFormErrors] = useState<{ [key: string]: string }>({});
  
  // Computed values
  const totalDuration = selectedServices.reduce((sum, service) => sum + service.durationMinutes, 0);
  const totalPrice = selectedServices.reduce((sum, service) => sum + service.price, 0);
  
  // Fetch services on mount
  useEffect(() => {
    // Fetch services only once when component mounts
    getServices(true);
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, []);
  
  // When date changes, fetch available time slots
  useEffect(() => {
    if (selectedDate && user?.id) {
      // Clear previous time slots and selected time
      clearTimeSlots();
      setSelectedTimeSlot(null);
      
      // Format date for API
      const formattedDate = format(selectedDate, 'yyyy-MM-dd');
      console.log('Formatted date for API:', formattedDate);
      
      // TODO: Replace with actual provider ID, for now using 1
      const providerId = 1;
      
      getAvailableTimeSlots(providerId, formattedDate);
    }
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [selectedDate, user?.id]);
  
  // Handle next button click
  const handleNext = () => {
    const errors: { [key: string]: string } = {};
    
    // Validate current step
    if (activeStep === 0) {
      if (selectedServices.length === 0) {
        errors.services = 'Selectați cel puțin un serviciu';
      }
    } else if (activeStep === 1) {
      if (!selectedDate) {
        errors.date = 'Selectați o dată';
      }
      if (!selectedTimeSlot) {
        errors.time = 'Selectați o oră';
      }
    }
    
    // If there are errors, show them and don't proceed
    if (Object.keys(errors).length > 0) {
      setFormErrors(errors);
      return;
    }
    
    // Clear any previous errors
    setFormErrors({});
    
    // If this is the last step, create the appointment
    if (activeStep === steps.length - 1) {
      handleCreateAppointment();
    } else {
      // Otherwise, go to next step
      setActiveStep((prevActiveStep) => prevActiveStep + 1);
    }
  };
  
  // Handle back button click
  const handleBack = () => {
    setActiveStep((prevActiveStep) => prevActiveStep - 1);
  };
  
  // Handle service selection
  const handleServiceToggle = (service: Service) => {
    setSelectedServices((prev) => {
      const serviceIndex = prev.findIndex(s => s.id === service.id);
      if (serviceIndex === -1) {
        // Add service
        return [...prev, service];
      } else {
        // Remove service
        return prev.filter(s => s.id !== service.id);
      }
    });
  };
  
  // Handle time slot selection
  const handleTimeSlotSelect = (timeSlot: string) => {
    setSelectedTimeSlot(timeSlot);
  };
  
  // Create appointment
  const handleCreateAppointment = async () => {
    if (!user?.id || !selectedTimeSlot) return;
    
    // TODO: Replace with actual provider ID, for now using 1
    const providerId = 1;
    
    const appointmentData = {
      clientId: user.id,
      providerId: providerId,
      startTime: selectedTimeSlot,
      serviceIds: selectedServices.map(service => service.id),
      notes: notes.trim() || undefined
    };
    
    const result = await createAppointment(appointmentData);
    
    if (result) {
      navigate('/appointments');
    }
  };
  
  // Render step content based on active step
  const getStepContent = (step: number) => {
    switch (step) {
      case 0:
        return (
          <Box>
            <Typography variant="h6" gutterBottom>
              Selectați serviciile dorite
            </Typography>
            
            {formErrors.services && (
              <Alert severity="error" sx={{ mb: 2 }}>
                {formErrors.services}
              </Alert>
            )}
            
            <Grid container spacing={3}>
              {services.map((service) => (
                <Grid item xs={12} sm={6} md={4} key={service.id}>
                  <Card 
                    variant="outlined"
                    sx={{ 
                      height: '100%',
                      border: selectedServices.some(s => s.id === service.id) 
                        ? '2px solid' 
                        : '1px solid',
                      borderColor: selectedServices.some(s => s.id === service.id)
                        ? 'primary.main'
                        : 'divider'
                    }}
                  >
                    <CardActionArea 
                      onClick={() => handleServiceToggle(service)}
                      sx={{ height: '100%', display: 'flex', flexDirection: 'column', alignItems: 'stretch' }}
                    >
                      {service.imageUrl && (
                        <CardMedia
                          component="img"
                          height="140"
                          image={service.imageUrl}
                          alt={service.name}
                        />
                      )}
                      <CardContent sx={{ flexGrow: 1 }}>
                        <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'flex-start' }}>
                          <Typography variant="h6" component="div">
                            {service.name}
                          </Typography>
                          {selectedServices.some(s => s.id === service.id) && (
                            <CheckCircleIcon color="primary" />
                          )}
                        </Box>
                        
                        {service.description && (
                          <Typography variant="body2" color="text.secondary" sx={{ mt: 1 }}>
                            {service.description}
                          </Typography>
                        )}
                        
                        <Box sx={{ display: 'flex', justifyContent: 'space-between', mt: 2 }}>
                          <Typography variant="body2" color="text.secondary">
                            <TimeIcon fontSize="small" sx={{ verticalAlign: 'middle', mr: 0.5 }} />
                            {service.durationMinutes} min
                          </Typography>
                          <Typography variant="subtitle1">
                            {service.price} lei
                          </Typography>
                        </Box>
                      </CardContent>
                    </CardActionArea>
                  </Card>
                </Grid>
              ))}
            </Grid>
            
            {selectedServices.length > 0 && (
              <Paper variant="outlined" sx={{ mt: 3, p: 2 }}>
                <Typography variant="subtitle1" gutterBottom>
                  Servicii selectate:
                </Typography>
                {selectedServices.map((service) => (
                  <Box key={service.id} sx={{ display: 'flex', justifyContent: 'space-between', mb: 1 }}>
                    <Typography variant="body1">
                      {service.name} ({service.durationMinutes} min)
                    </Typography>
                    <Typography variant="body1">
                      {service.price} lei
                    </Typography>
                  </Box>
                ))}
                <Divider sx={{ my: 1 }} />
                <Box sx={{ display: 'flex', justifyContent: 'space-between' }}>
                  <Typography variant="subtitle1">
                    Durată totală: {totalDuration} min
                  </Typography>
                  <Typography variant="subtitle1">
                    Total: {totalPrice} lei
                  </Typography>
                </Box>
              </Paper>
            )}
          </Box>
        );
      case 1:
        return (
          <Box>
            <Typography variant="h6" gutterBottom>
              Selectați data și ora
            </Typography>
            
            <Grid container spacing={3}>
              <Grid item xs={12} md={6}>
                <LocalizationProvider dateAdapter={AdapterDateFns}>
                  <DatePicker 
                    label="Data programării"
                    value={selectedDate}
                    onChange={(newDate) => setSelectedDate(newDate)}
                    disablePast
                    maxDate={addDays(new Date(), 30)} // Allow booking up to 30 days ahead
                    slotProps={{ 
                      textField: { 
                        fullWidth: true,
                        error: !!formErrors.date,
                        helperText: formErrors.date
                      } 
                    }}
                  />
                </LocalizationProvider>
              </Grid>
            </Grid>
            
            <Typography variant="subtitle1" sx={{ mt: 3, mb: 2 }}>
              Ore disponibile:
            </Typography>
            
            {!selectedDate ? (
              <Alert severity="info">
                Selectați o dată pentru a vedea orele disponibile
              </Alert>
            ) : isLoading ? (
              <Box sx={{ display: 'flex', justifyContent: 'center', p: 4 }}>
                <CircularProgress />
              </Box>
            ) : availableTimeSlots.length === 0 ? (
              <Alert severity="warning">
                Nu există ore disponibile pentru data selectată. Vă rugăm să selectați o altă dată.
              </Alert>
            ) : (
              <>
                {formErrors.time && (
                  <Alert severity="error" sx={{ mb: 2 }}>
                    {formErrors.time}
                  </Alert>
                )}
                
                <FormControl component="fieldset">
                  <RadioGroup 
                    value={selectedTimeSlot || ''}
                    onChange={(e) => handleTimeSlotSelect(e.target.value)}
                  >
                    <Grid container spacing={2}>
                      {availableTimeSlots
                        .filter(slot => slot.available)
                        .map((timeSlot, index) => (
                          <Grid item xs={6} sm={4} md={3} key={index}>
                            <FormControlLabel
                              value={timeSlot.startTime}
                              control={<Radio />}
                              label={format(parseISO(timeSlot.startTime), 'HH:mm')}
                              sx={{
                                display: 'flex',
                                border: '1px solid',
                                borderColor: 'divider',
                                borderRadius: 1,
                                p: 1,
                                width: '100%',
                                m: 0
                              }}
                            />
                          </Grid>
                        ))}
                    </Grid>
                  </RadioGroup>
                </FormControl>
              </>
            )}
            
            <Typography variant="subtitle1" sx={{ mt: 4, mb: 2 }}>
              Note (opțional):
            </Typography>
            <TextField
              multiline
              rows={3}
              fullWidth
              placeholder="Adăugați orice informații suplimentare pentru programarea dvs."
              value={notes}
              onChange={(e) => setNotes(e.target.value)}
              inputProps={{ maxLength: 500 }}
            />
          </Box>
        );
      case 2:
        return (
          <Box>
            <Typography variant="h6" gutterBottom>
              Confirmarea programării
            </Typography>
            
            <Paper variant="outlined" sx={{ p: 3, mb: 3 }}>
              <Grid container spacing={2}>
                <Grid item xs={12}>
                  <Typography variant="subtitle1">
                    Servicii selectate:
                  </Typography>
                  {selectedServices.map((service) => (
                    <Box key={service.id} sx={{ display: 'flex', justifyContent: 'space-between', mt: 1 }}>
                      <Typography variant="body1">
                        {service.name} ({service.durationMinutes} min)
                      </Typography>
                      <Typography variant="body1">
                        {service.price} lei
                      </Typography>
                    </Box>
                  ))}
                </Grid>
                
                <Grid item xs={12}>
                  <Divider sx={{ my: 2 }} />
                </Grid>
                
                <Grid item xs={12} sm={6}>
                  <Box sx={{ display: 'flex', alignItems: 'center' }}>
                    <CalendarIcon sx={{ mr: 1, color: 'primary.main' }} />
                    <Typography variant="body1">
                      Data: {selectedDate ? format(selectedDate, 'dd MMMM yyyy') : ''}
                    </Typography>
                  </Box>
                </Grid>
                
                <Grid item xs={12} sm={6}>
                  <Box sx={{ display: 'flex', alignItems: 'center' }}>
                    <TimeIcon sx={{ mr: 1, color: 'primary.main' }} />
                    <Typography variant="body1">
                      Ora: {selectedTimeSlot ? format(parseISO(selectedTimeSlot), 'HH:mm') : ''}
                    </Typography>
                  </Box>
                </Grid>
                
                {notes && (
                  <Grid item xs={12}>
                    <Typography variant="subtitle1" sx={{ mt: 1 }}>
                      Note:
                    </Typography>
                    <Typography variant="body1">
                      {notes}
                    </Typography>
                  </Grid>
                )}
                
                <Grid item xs={12}>
                  <Divider sx={{ my: 2 }} />
                </Grid>
                
                <Grid item xs={12}>
                  <Box sx={{ display: 'flex', justifyContent: 'space-between' }}>
                    <Typography variant="subtitle1">
                      Durată totală:
                    </Typography>
                    <Typography variant="subtitle1">
                      {totalDuration} min
                    </Typography>
                  </Box>
                </Grid>
                
                <Grid item xs={12}>
                  <Box sx={{ display: 'flex', justifyContent: 'space-between' }}>
                    <Typography variant="subtitle1">
                      Preț total:
                    </Typography>
                    <Typography variant="h6" color="primary.main">
                      {totalPrice} lei
                    </Typography>
                  </Box>
                </Grid>
              </Grid>
            </Paper>
            
            <Alert severity="info" sx={{ mb: 2 }}>
              Odată creată, programarea va avea inițial statusul "În așteptare" și va fi confirmată de către salon.
            </Alert>
          </Box>
        );
      default:
        return 'Unknown step';
    }
  };
  
  return (
    <Container maxWidth="md" sx={{ mt: 4, mb: 6 }}>
      <Paper sx={{ p: 3 }}>
        <Typography variant="h4" component="h1" align="center" gutterBottom>
          Programare nouă
        </Typography>
        
        {error && (
          <Alert severity="error" sx={{ mb: 3 }}>
            {error}
          </Alert>
        )}
        
        <Stepper activeStep={activeStep} sx={{ mb: 4 }}>
          {steps.map((label) => (
            <Step key={label}>
              <StepLabel>{label}</StepLabel>
            </Step>
          ))}
        </Stepper>
        
        {getStepContent(activeStep)}
        
        <Box sx={{ display: 'flex', justifyContent: 'space-between', mt: 4 }}>
          <Button
            disabled={activeStep === 0 || isLoading}
            onClick={handleBack}
          >
            Înapoi
          </Button>
          
          <Button
            variant="contained"
            color="primary"
            onClick={handleNext}
            disabled={isLoading}
          >
            {isLoading ? (
              <CircularProgress size={24} color="inherit" />
            ) : activeStep === steps.length - 1 ? (
              'Confirmă programarea'
            ) : (
              'Continuă'
            )}
          </Button>
        </Box>
      </Paper>
    </Container>
  );
};

export default NewAppointmentPage;

================
File: src/pages/NotFoundPage.tsx
================
import React from 'react';
import { Link as RouterLink } from 'react-router-dom';
import {
  Box,
  Container,
  Typography,
  Button,
  Paper
} from '@mui/material';
import { Home as HomeIcon } from '@mui/icons-material';

const NotFoundPage: React.FC = () => {
  return (
    <Container maxWidth="md">
      <Paper
        elevation={3}
        sx={{
          my: 8,
          p: 6,
          display: 'flex',
          flexDirection: 'column',
          alignItems: 'center',
          textAlign: 'center'
        }}
      >
        <Typography variant="h1" component="h1" sx={{ fontWeight: 'bold', mb: 2 }}>
          404
        </Typography>
        
        <Typography variant="h4" component="h2" gutterBottom>
          Pagină Negăsită
        </Typography>
        
        <Typography variant="body1" color="text.secondary" paragraph>
          Pagina pe care o cauți este posibil să fi fost eliminată, să-și fi schimbat numele
          sau este temporar indisponibilă.
        </Typography>
        
        <Box component="img" 
          src="/api/placeholder/400/300" 
          alt="Pagină negăsită" 
          sx={{ 
            width: '100%',
            maxWidth: 400,
            my: 4
          }}
        />
        
        <Button
          component={RouterLink}
          to="/"
          variant="contained"
          color="primary"
          startIcon={<HomeIcon />}
          size="large"
        >
          Înapoi la Pagina Principală
        </Button>
      </Paper>
    </Container>
  );
};

export default NotFoundPage;

================
File: src/pages/RegisterPage.tsx
================
import React, { useEffect } from 'react';
import { useNavigate } from 'react-router-dom';
import { Container } from '@mui/material';
import RegisterForm from '../components/auth/RegisterForm';
import { useAuth } from '../hooks/useAuth';

const RegisterPage: React.FC = () => {
  const { isAuthenticated } = useAuth();
  const navigate = useNavigate();
  
  // Redirect if already authenticated
  useEffect(() => {
    if (isAuthenticated) {
      navigate('/dashboard');
    }
  }, [isAuthenticated, navigate]);
  
  return (
    <Container>
      <RegisterForm />
    </Container>
  );
};

export default RegisterPage;

================
File: src/pages/ServiceManagementPage.tsx
================
// src/pages/ServiceManagementPage.tsx
import React, { useEffect, useState } from 'react';
import { useAuth } from '../hooks/useAuth';
import { useAppointments } from '../hooks/useAppointments';
import * as appointmentApi from '../utils/appointmentApi';
import { Service } from '../types/appointment';
import {
  Container,
  Typography,
  Box,
  Paper,
  Table,
  TableBody,
  TableCell,
  TableContainer,
  TableHead,
  TableRow,
  Button,
  IconButton,
  Switch,
  Dialog,
  DialogTitle,
  DialogContent,
  DialogActions,
  TextField,
  InputAdornment,
  FormControlLabel,
  CircularProgress,
  Alert,
  Snackbar
} from '@mui/material';
import {
  Add as AddIcon,
  Edit as EditIcon,
  DeleteOutline as DeleteIcon,
  AccessTime as TimeIcon
} from '@mui/icons-material';

const ServiceManagementPage: React.FC = () => {
  const { user } = useAuth();
  const { services, getServices, isLoading, error } = useAppointments();
  
  // UI State
  const [openDialog, setOpenDialog] = useState(false);
  const [dialogMode, setDialogMode] = useState<'add' | 'edit'>('add');
  const [selectedService, setSelectedService] = useState<Service | null>(null);
  const [snackbarOpen, setSnackbarOpen] = useState(false);
  const [snackbarMessage, setSnackbarMessage] = useState('');
  const [snackbarSeverity, setSnackbarSeverity] = useState<'success' | 'error'>('success');
  
  // Form State
  const [formName, setFormName] = useState('');
  const [formDescription, setFormDescription] = useState('');
  const [formPrice, setFormPrice] = useState('');
  const [formDuration, setFormDuration] = useState('');
  const [formActive, setFormActive] = useState(true);
  const [formImageUrl, setFormImageUrl] = useState('');
  const [formErrors, setFormErrors] = useState<{ [key: string]: string }>({});
  
  // Check if user has admin role
  const isAdmin = user?.roles.includes('ROLE_ADMIN');
  
  // Fetch services on mount
  useEffect(() => {
    getServices(false); // Get all services, not just active ones
  }, [getServices]);
  
  // Open dialog for adding a new service
  const handleAddService = () => {
    setDialogMode('add');
    setSelectedService(null);
    resetForm();
    setOpenDialog(true);
  };
  
  // Open dialog for editing an existing service
  const handleEditService = (service: Service) => {
    setDialogMode('edit');
    setSelectedService(service);
    
    // Populate form with service data
    setFormName(service.name);
    setFormDescription(service.description || '');
    setFormPrice(service.price.toString());
    setFormDuration(service.durationMinutes.toString());
    setFormActive(service.active);
    setFormImageUrl(service.imageUrl || '');
    
    setOpenDialog(true);
  };
  
  // Reset form fields
  const resetForm = () => {
    setFormName('');
    setFormDescription('');
    setFormPrice('');
    setFormDuration('');
    setFormActive(true);
    setFormImageUrl('');
    setFormErrors({});
  };
  
  // Handle dialog close
  const handleCloseDialog = () => {
    setOpenDialog(false);
    resetForm();
  };
  
  // Validate form
  const validateForm = (): boolean => {
    const errors: { [key: string]: string } = {};
    
    if (!formName.trim()) {
      errors.name = 'Numele serviciului este obligatoriu';
    }
    
    if (!formPrice.trim()) {
      errors.price = 'Prețul este obligatoriu';
    } else if (isNaN(parseFloat(formPrice)) || parseFloat(formPrice) < 0) {
      errors.price = 'Prețul trebuie să fie un număr pozitiv';
    }
    
    if (!formDuration.trim()) {
      errors.duration = 'Durata este obligatorie';
    } else if (isNaN(parseInt(formDuration)) || parseInt(formDuration) <= 0) {
      errors.duration = 'Durata trebuie să fie un număr pozitiv';
    }
    
    setFormErrors(errors);
    return Object.keys(errors).length === 0;
  };
  
  // Handle save service
  const handleSaveService = async () => {
    if (!validateForm()) return;
    
    const serviceData: Service = {
      id: selectedService?.id || 0,
      name: formName,
      description: formDescription || undefined,
      price: parseFloat(formPrice),
      durationMinutes: parseInt(formDuration),
      active: formActive,
      imageUrl: formImageUrl || undefined
    };
    
    try {
      if (dialogMode === 'add') {
        await appointmentApi.createService(serviceData);
        showSnackbar('Serviciu adăugat cu succes', 'success');
      } else {
        await appointmentApi.updateService(serviceData.id, serviceData);
        showSnackbar('Serviciu actualizat cu succes', 'success');
      }
      
      // Refresh services list
      getServices(false);
      handleCloseDialog();
    } catch (error) {
      showSnackbar('A apărut o eroare la salvarea serviciului', 'error');
    }
  };
  
  // Handle toggle service active status
  const handleToggleActive = async (service: Service, newStatus: boolean) => {
    try {
      await appointmentApi.setServiceActiveStatus(service.id, newStatus);
      showSnackbar(`Serviciu ${newStatus ? 'activat' : 'dezactivat'} cu succes`, 'success');
      
      // Refresh services list
      getServices(false);
    } catch (error) {
      showSnackbar('A apărut o eroare la modificarea statusului', 'error');
    }
  };
  
  // Show snackbar message
  const showSnackbar = (message: string, severity: 'success' | 'error') => {
    setSnackbarMessage(message);
    setSnackbarSeverity(severity);
    setSnackbarOpen(true);
  };
  
  // Handle snackbar close
  const handleSnackbarClose = () => {
    setSnackbarOpen(false);
  };
  
  return (
    <Container maxWidth="lg" sx={{ mt: 4, mb: 4 }}>
      <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', mb: 3 }}>
        <Typography variant="h4" component="h1">
          Gestionare Servicii
        </Typography>
        
        {isAdmin && (
          <Button
            variant="contained"
            color="primary"
            startIcon={<AddIcon />}
            onClick={handleAddService}
          >
            Adaugă Serviciu
          </Button>
        )}
      </Box>
      
      {error && (
        <Alert severity="error" sx={{ mb: 3 }}>
          {error}
        </Alert>
      )}
      
      {isLoading ? (
        <Box sx={{ display: 'flex', justifyContent: 'center', p: 4 }}>
          <CircularProgress />
        </Box>
      ) : services.length === 0 ? (
        <Alert severity="info">
          Nu există servicii disponibile. Adăugați primul serviciu.
        </Alert>
      ) : (
        <TableContainer component={Paper}>
          <Table>
            <TableHead>
              <TableRow>
                <TableCell>Nume</TableCell>
                <TableCell>Descriere</TableCell>
                <TableCell align="right">Durată (min)</TableCell>
                <TableCell align="right">Preț (lei)</TableCell>
                <TableCell align="center">Activ</TableCell>
                {isAdmin && <TableCell align="center">Acțiuni</TableCell>}
              </TableRow>
            </TableHead>
            <TableBody>
              {services.map((service) => (
                <TableRow key={service.id}>
                  <TableCell component="th" scope="row">
                    {service.name}
                  </TableCell>
                  <TableCell>{service.description || '-'}</TableCell>
                  <TableCell align="right">
                    <Box sx={{ display: 'flex', alignItems: 'center', justifyContent: 'flex-end' }}>
                      <TimeIcon fontSize="small" sx={{ mr: 1 }} />
                      {service.durationMinutes}
                    </Box>
                  </TableCell>
                  <TableCell align="right">{service.price}</TableCell>
                  <TableCell align="center">
                    {isAdmin ? (
                      <Switch
                        checked={service.active}
                        onChange={(e) => handleToggleActive(service, e.target.checked)}
                        color="primary"
                      />
                    ) : (
                      service.active ? 'Da' : 'Nu'
                    )}
                  </TableCell>
                  {isAdmin && (
                    <TableCell align="center">
                      <IconButton
                        color="primary"
                        onClick={() => handleEditService(service)}
                        size="small"
                      >
                        <EditIcon />
                      </IconButton>
                    </TableCell>
                  )}
                </TableRow>
              ))}
            </TableBody>
          </Table>
        </TableContainer>
      )}
      
      {/* Add/Edit Service Dialog */}
      <Dialog open={openDialog} onClose={handleCloseDialog} maxWidth="sm" fullWidth>
        <DialogTitle>
          {dialogMode === 'add' ? 'Adaugă Serviciu Nou' : 'Editează Serviciu'}
        </DialogTitle>
        <DialogContent>
          <Box component="form" noValidate sx={{ mt: 2 }}>
            <TextField
              fullWidth
              label="Nume Serviciu"
              margin="normal"
              value={formName}
              onChange={(e) => setFormName(e.target.value)}
              error={!!formErrors.name}
              helperText={formErrors.name}
              required
            />
            
            <TextField
              fullWidth
              label="Descriere"
              margin="normal"
              value={formDescription}
              onChange={(e) => setFormDescription(e.target.value)}
              multiline
              rows={3}
            />
            
            <Box sx={{ display: 'flex', gap: 2, mt: 2 }}>
              <TextField
                fullWidth
                label="Preț"
                margin="normal"
                value={formPrice}
                onChange={(e) => setFormPrice(e.target.value)}
                error={!!formErrors.price}
                helperText={formErrors.price}
                InputProps={{
                  endAdornment: <InputAdornment position="end">lei</InputAdornment>,
                }}
                required
              />
              
              <TextField
                fullWidth
                label="Durată"
                margin="normal"
                value={formDuration}
                onChange={(e) => setFormDuration(e.target.value)}
                error={!!formErrors.duration}
                helperText={formErrors.duration}
                InputProps={{
                  endAdornment: <InputAdornment position="end">min</InputAdornment>,
                }}
                required
              />
            </Box>
            
            <TextField
              fullWidth
              label="URL Imagine"
              margin="normal"
              value={formImageUrl}
              onChange={(e) => setFormImageUrl(e.target.value)}
              placeholder="https://example.com/image.jpg"
            />
            
            <FormControlLabel
              control={
                <Switch
                  checked={formActive}
                  onChange={(e) => setFormActive(e.target.checked)}
                  color="primary"
                />
              }
              label="Serviciu Activ"
              sx={{ mt: 2 }}
            />
          </Box>
        </DialogContent>
        <DialogActions>
          <Button onClick={handleCloseDialog}>Anulează</Button>
          <Button onClick={handleSaveService} variant="contained" color="primary">
            Salvează
          </Button>
        </DialogActions>
      </Dialog>
      
      {/* Snackbar for notifications */}
      <Snackbar
        open={snackbarOpen}
        autoHideDuration={6000}
        onClose={handleSnackbarClose}
        anchorOrigin={{ vertical: 'bottom', horizontal: 'center' }}
      >
        <Alert
          onClose={handleSnackbarClose}
          severity={snackbarSeverity}
          variant="filled"
          sx={{ width: '100%' }}
        >
          {snackbarMessage}
        </Alert>
      </Snackbar>
    </Container>
  );
};

export default ServiceManagementPage;

================
File: src/store/appointmentSlice.ts
================
// src/store/appointmentSlice.ts
import { createSlice, createAsyncThunk, PayloadAction } from '@reduxjs/toolkit';
import * as appointmentApi from '../utils/appointmentApi';
import { 
  Appointment, 
  Service, 
  CreateAppointmentRequest,
  UpdateAppointmentRequest,
  AvailableTimeSlotsResponse,
  TimeSlot
} from '../types/appointment';

interface AppointmentState {
  appointments: Appointment[];
  currentAppointment: Appointment | null;
  services: Service[];
  availableTimeSlots: TimeSlot[];
  isLoading: boolean;
  error: string | null;
}

const initialState: AppointmentState = {
  appointments: [],
  currentAppointment: null,
  services: [],
  availableTimeSlots: [],
  isLoading: false,
  error: null
};

// Async thunks for appointments
export const fetchClientAppointments = createAsyncThunk(
  'appointments/fetchClientAppointments',
  async (clientId: number, { rejectWithValue }) => {
    try {
      return await appointmentApi.getClientAppointments(clientId);
    } catch (error: any) {
      return rejectWithValue(error.response?.data?.detail || 'Failed to fetch appointments');
    }
  }
);

export const fetchProviderAppointments = createAsyncThunk(
  'appointments/fetchProviderAppointments',
  async (providerId: number, { rejectWithValue }) => {
    try {
      return await appointmentApi.getProviderAppointments(providerId);
    } catch (error: any) {
      return rejectWithValue(error.response?.data?.detail || 'Failed to fetch appointments');
    }
  }
);

export const fetchAppointmentById = createAsyncThunk(
  'appointments/fetchAppointmentById',
  async (id: number, { rejectWithValue }) => {
    try {
      return await appointmentApi.getAppointmentById(id);
    } catch (error: any) {
      return rejectWithValue(error.response?.data?.detail || 'Failed to fetch appointment');
    }
  }
);

export const createNewAppointment = createAsyncThunk(
  'appointments/createAppointment',
  async (request: CreateAppointmentRequest, { rejectWithValue }) => {
    try {
      return await appointmentApi.createAppointment(request);
    } catch (error: any) {
      return rejectWithValue(error.response?.data?.detail || 'Failed to create appointment');
    }
  }
);

export const updateExistingAppointment = createAsyncThunk(
  'appointments/updateAppointment',
  async ({ id, request }: { id: number, request: UpdateAppointmentRequest }, { rejectWithValue }) => {
    try {
      return await appointmentApi.updateAppointment(id, request);
    } catch (error: any) {
      return rejectWithValue(error.response?.data?.detail || 'Failed to update appointment');
    }
  }
);

export const cancelExistingAppointment = createAsyncThunk(
  'appointments/cancelAppointment',
  async (id: number, { rejectWithValue }) => {
    try {
      return await appointmentApi.cancelAppointment(id);
    } catch (error: any) {
      return rejectWithValue(error.response?.data?.detail || 'Failed to cancel appointment');
    }
  }
);

export const fetchAvailableTimeSlots = createAsyncThunk(
  'appointments/fetchAvailableTimeSlots',
  async ({ providerId, date }: { providerId: number, date: string }, { rejectWithValue }) => {
    try {
      return await appointmentApi.getAvailableTimeSlots(providerId, date);
    } catch (error: any) {
      return rejectWithValue(error.response?.data?.detail || 'Failed to fetch available time slots');
    }
  }
);

// Async thunks for services
export const fetchServices = createAsyncThunk(
  'appointments/fetchServices',
  async (activeOnly: boolean = true, { rejectWithValue }) => {
    try {
      return await appointmentApi.getAllServices(activeOnly);
    } catch (error: any) {
      return rejectWithValue(error.response?.data?.detail || 'Failed to fetch services');
    }
  }
);

const appointmentSlice = createSlice({
  name: 'appointments',
  initialState,
  reducers: {
    resetAppointmentError: (state) => {
      state.error = null;
    },
    resetCurrentAppointment: (state) => {
      state.currentAppointment = null;
    },
    clearAvailableTimeSlots: (state) => {
      state.availableTimeSlots = [];
    }
  },
  extraReducers: (builder) => {
    // Fetch client appointments
    builder
      .addCase(fetchClientAppointments.pending, (state) => {
        state.isLoading = true;
        state.error = null;
      })
      .addCase(fetchClientAppointments.fulfilled, (state, action: PayloadAction<Appointment[]>) => {
        state.isLoading = false;
        state.appointments = action.payload;
      })
      .addCase(fetchClientAppointments.rejected, (state, action) => {
        state.isLoading = false;
        state.error = action.payload as string;
      })
    
    // Fetch provider appointments
    builder
      .addCase(fetchProviderAppointments.pending, (state) => {
        state.isLoading = true;
        state.error = null;
      })
      .addCase(fetchProviderAppointments.fulfilled, (state, action: PayloadAction<Appointment[]>) => {
        state.isLoading = false;
        state.appointments = action.payload;
      })
      .addCase(fetchProviderAppointments.rejected, (state, action) => {
        state.isLoading = false;
        state.error = action.payload as string;
      })
    
    // Fetch appointment by ID
    builder
      .addCase(fetchAppointmentById.pending, (state) => {
        state.isLoading = true;
        state.error = null;
      })
      .addCase(fetchAppointmentById.fulfilled, (state, action: PayloadAction<Appointment>) => {
        state.isLoading = false;
        state.currentAppointment = action.payload;
      })
      .addCase(fetchAppointmentById.rejected, (state, action) => {
        state.isLoading = false;
        state.error = action.payload as string;
      })
    
    // Create appointment
    builder
      .addCase(createNewAppointment.pending, (state) => {
        state.isLoading = true;
        state.error = null;
      })
      .addCase(createNewAppointment.fulfilled, (state, action: PayloadAction<Appointment>) => {
        state.isLoading = false;
        state.appointments.push(action.payload);
        state.currentAppointment = action.payload;
      })
      .addCase(createNewAppointment.rejected, (state, action) => {
        state.isLoading = false;
        state.error = action.payload as string;
      })
    
    // Update appointment
    builder
      .addCase(updateExistingAppointment.pending, (state) => {
        state.isLoading = true;
        state.error = null;
      })
      .addCase(updateExistingAppointment.fulfilled, (state, action: PayloadAction<Appointment>) => {
        state.isLoading = false;
        const index = state.appointments.findIndex(apt => apt.id === action.payload.id);
        if (index !== -1) {
          state.appointments[index] = action.payload;
        }
        state.currentAppointment = action.payload;
      })
      .addCase(updateExistingAppointment.rejected, (state, action) => {
        state.isLoading = false;
        state.error = action.payload as string;
      })
    
    // Cancel appointment
    builder
      .addCase(cancelExistingAppointment.pending, (state) => {
        state.isLoading = true;
        state.error = null;
      })
      .addCase(cancelExistingAppointment.fulfilled, (state, action: PayloadAction<Appointment>) => {
        state.isLoading = false;
        const index = state.appointments.findIndex(apt => apt.id === action.payload.id);
        if (index !== -1) {
          state.appointments[index] = action.payload;
        }
        if (state.currentAppointment?.id === action.payload.id) {
          state.currentAppointment = action.payload;
        }
      })
      .addCase(cancelExistingAppointment.rejected, (state, action) => {
        state.isLoading = false;
        state.error = action.payload as string;
      })
    
    // Fetch available time slots
    builder
      .addCase(fetchAvailableTimeSlots.pending, (state) => {
        state.isLoading = true;
        state.error = null;
      })
      .addCase(fetchAvailableTimeSlots.fulfilled, (state, action: PayloadAction<AvailableTimeSlotsResponse>) => {
        state.isLoading = false;
        state.availableTimeSlots = action.payload.availableSlots;
      })
      .addCase(fetchAvailableTimeSlots.rejected, (state, action) => {
        state.isLoading = false;
        state.error = action.payload as string;
      })
    
    // Fetch services
    builder
      .addCase(fetchServices.pending, (state) => {
        state.isLoading = true;
        state.error = null;
      })
      .addCase(fetchServices.fulfilled, (state, action: PayloadAction<Service[]>) => {
        state.isLoading = false;
        state.services = action.payload;
      })
      .addCase(fetchServices.rejected, (state, action) => {
        state.isLoading = false;
        state.error = action.payload as string;
      });
  }
});

export const { 
  resetAppointmentError, 
  resetCurrentAppointment,
  clearAvailableTimeSlots
} = appointmentSlice.actions;

export default appointmentSlice.reducer;

================
File: src/store/authSlice.ts
================
import { createSlice, createAsyncThunk, PayloadAction } from '@reduxjs/toolkit';
import api from '../utils/axios';
import { 
  AuthState, 
  LoginRequest, 
  RegisterRequest, 
  JwtResponse,
  User 
} from '../types';
import { 
  setAccessToken, 
  setRefreshToken, 
  clearTokens 
} from '../utils/tokenUtils';

// Initial state
const initialState: AuthState = {
  user: null,
  isAuthenticated: false,
  isLoading: false,
  error: null
};

// Async thunks
export const login = createAsyncThunk(
  'auth/login',
  async (credentials: LoginRequest, { rejectWithValue }) => {
    try {
      const response = await api.post<JwtResponse>('/auth/login', credentials);
      return response.data;
    } catch (error: any) {
      return rejectWithValue(error.response?.data?.detail || 'Login failed');
    }
  }
);

export const register = createAsyncThunk(
  'auth/register',
  async (userData: RegisterRequest, { rejectWithValue }) => {
    try {
      const response = await api.post<User>('/auth/register', userData);
      return response.data;
    } catch (error: any) {
      return rejectWithValue(error.response?.data?.detail || 'Registration failed');
    }
  }
);

export const getCurrentUser = createAsyncThunk(
  'auth/getCurrentUser',
  async (_, { rejectWithValue }) => {
    try {
      const response = await api.get<User>('/users/me');
      return response.data;
    } catch (error: any) {
      return rejectWithValue(error.response?.data?.detail || 'Failed to get user data');
    }
  }
);

export const logout = createAsyncThunk(
  'auth/logout',
  async (_, { rejectWithValue }) => {
    try {
      await api.post('/auth/logout');
      clearTokens();
      return true;
    } catch (error: any) {
      // Even if the server request fails, we should clear local tokens
      clearTokens();
      return rejectWithValue(error.response?.data?.detail || 'Logout failed');
    }
  }
);

// Auth slice
const authSlice = createSlice({
  name: 'auth',
  initialState,
  reducers: {
    resetAuthError: (state) => {
      state.error = null;
    },
  },
  extraReducers: (builder) => {
    // Login
    builder
      .addCase(login.pending, (state) => {
        state.isLoading = true;
        state.error = null;
      })
      .addCase(login.fulfilled, (state, action: PayloadAction<JwtResponse>) => {
        state.isLoading = false;
        state.isAuthenticated = true;
        state.user = {
          id: action.payload.id,
          email: action.payload.email,
          username: action.payload.username,
          roles: action.payload.roles,
          // These will be populated when we fetch the full user profile
          firstName: '',
          lastName: '',
          country: 'RO' as any,
          active: true
        };
        
        // Store tokens
        setAccessToken(action.payload.token);
        setRefreshToken(action.payload.refreshToken);
      })
      .addCase(login.rejected, (state, action) => {
        state.isLoading = false;
        state.error = action.payload as string;
      })
      
    // Register
    builder
      .addCase(register.pending, (state) => {
        state.isLoading = true;
        state.error = null;
      })
      .addCase(register.fulfilled, (state, action: PayloadAction<User>) => {
        state.isLoading = false;
        // On register success, we don't log in automatically
        // User needs to log in with their credentials
      })
      .addCase(register.rejected, (state, action) => {
        state.isLoading = false;
        state.error = action.payload as string;
      })
      
    // Get current user
    builder
      .addCase(getCurrentUser.pending, (state) => {
        state.isLoading = true;
      })
      .addCase(getCurrentUser.fulfilled, (state, action: PayloadAction<User>) => {
        state.isLoading = false;
        state.isAuthenticated = true;
        state.user = action.payload;
      })
      .addCase(getCurrentUser.rejected, (state, action) => {
        state.isLoading = false;
        state.isAuthenticated = false;
        state.user = null;
        state.error = action.payload as string;
        // Clear tokens if user fetch fails (likely invalid tokens)
        clearTokens();
      })
      
    // Logout
    builder
      .addCase(logout.fulfilled, (state) => {
        state.isAuthenticated = false;
        state.user = null;
      });
  },
});

export const { resetAuthError } = authSlice.actions;
export default authSlice.reducer;

================
File: src/store/store.ts
================
import { configureStore } from '@reduxjs/toolkit';
import authReducer from './authSlice';
import appointmentReducer from './appointmentSlice';

export const store = configureStore({
  reducer: {
    auth: authReducer,
    appointments: appointmentReducer,
  },
});

// Export types for better TypeScript integration
export type RootState = ReturnType<typeof store.getState>;
export type AppDispatch = typeof store.dispatch;

================
File: src/types/appointment.ts
================
import { User } from './index';

export enum AppointmentStatusEnum {
  PENDING = 'PENDING',
  CONFIRMED = 'CONFIRMED',
  CANCELLED = 'CANCELLED',
  COMPLETED = 'COMPLETED',
  NO_SHOW = 'NO_SHOW'
}

export enum ScheduleExceptionTypeEnum {
  DAY_OFF = 'DAY_OFF',
  SPECIAL_HOURS = 'SPECIAL_HOURS'
}

export interface Service {
  id: number;
  name: string;
  description?: string;
  price: number;
  durationMinutes: number;
  active: boolean;
  imageUrl?: string;
}

export interface Appointment {
  id: number;
  clientId: number;
  clientName: string;
  clientEmail: string;
  providerId: number;
  providerName: string;
  startTime: string;
  endTime: string;
  status: AppointmentStatusEnum;
  services: Service[];
  notes?: string;
  totalPrice: number;
}

export interface CreateAppointmentRequest {
  clientId: number;
  providerId: number;
  startTime: string;
  serviceIds: number[];
  notes?: string;
}

export interface UpdateAppointmentRequest {
  id: number;
  startTime?: string;
  serviceIds?: number[];
  notes?: string;
  status?: AppointmentStatusEnum;
}

export interface TimeSlot {
  startTime: string;
  endTime: string;
  durationMinutes: number;
  available: boolean;
}

export interface AvailableTimeSlotsResponse {
  providerId: number;
  date: string;
  availableSlots: TimeSlot[];
}

export interface TimeSlotConfig {
  id?: number;
  slotDurationMinutes: number;
  bufferTimeMinutes: number;
  bookingLeadDays: number;
  bookingAheadDays: number;
}

export interface WorkSchedule {
  id?: number;
  providerId: number;
  dayOfWeek: string; // 'MONDAY', 'TUESDAY', etc.
  startTime: string;
  endTime: string;
  active: boolean;
}

export interface ScheduleException {
  id?: number;
  providerId: number;
  exceptionDate: string;
  type: ScheduleExceptionTypeEnum;
  startTime?: string;
  endTime?: string;
  reason?: string;
}

export interface WeeklySchedule {
  providerId: number;
  providerName: string;
  regularSchedule: WorkSchedule[];
  exceptions: ScheduleException[];
}

export interface SetWorkScheduleRequest {
  providerId: number;
  scheduleEntries: WorkSchedule[];
}

================
File: src/types/index.ts
================
// User types
export enum CountryEnum {
  RO = 'RO',
  MD = 'MD'
}

export interface User {
  id: number;
  username?: string;
  email: string;
  country: CountryEnum;
  firstName: string;
  lastName: string;
  active: boolean;
  roles: string[];
}

// Authentication types
export interface LoginRequest {
  email: string;
  password: string;
}

export interface RegisterRequest {
  email: string;
  password: string;
  country: CountryEnum;
  firstName: string;
  lastName: string;
}

export interface JwtResponse {
  token: string;
  refreshToken: string;
  type: string;
  id: number;
  username?: string;
  email: string;
  roles: string[];
}

export interface RefreshTokenRequest {
  refreshToken: string;
}

export interface RefreshTokenResponse {
  accessToken: string;
  refreshToken: string;
  tokenType: string;
}

// Auth state for store
export interface AuthState {
  user: User | null;
  isAuthenticated: boolean;
  isLoading: boolean;
  error: string | null;
}

================
File: src/utils/appointmentApi.ts
================
import api from './axios';
import { 
  Appointment, 
  Service, 
  CreateAppointmentRequest, 
  UpdateAppointmentRequest,
  AvailableTimeSlotsResponse,
  TimeSlotConfig,
  WeeklySchedule,
  SetWorkScheduleRequest,
  ScheduleException
} from '../types/appointment';

// Appointment API calls
export const getAppointmentById = async (id: number): Promise<Appointment> => {
  const response = await api.get<Appointment>(`/appointments/${id}`);
  return response.data;
};

export const getClientAppointments = async (clientId: number): Promise<Appointment[]> => {
  const response = await api.get<Appointment[]>(`/appointments/client/${clientId}`);
  return response.data;
};

export const getProviderAppointments = async (providerId: number): Promise<Appointment[]> => {
  const response = await api.get<Appointment[]>(`/appointments/provider/${providerId}`);
  return response.data;
};

export const getAppointmentsByDateRange = async (startDate: string, endDate: string): Promise<Appointment[]> => {
  const response = await api.get<Appointment[]>(`/appointments/date-range`, {
    params: { startDate, endDate }
  });
  return response.data;
};

export const createAppointment = async (request: CreateAppointmentRequest): Promise<Appointment> => {
  const response = await api.post<Appointment>('/appointments', request);
  return response.data;
};

export const updateAppointment = async (id: number, request: UpdateAppointmentRequest): Promise<Appointment> => {
  const response = await api.put<Appointment>(`/appointments/${id}`, request);
  return response.data;
};

export const cancelAppointment = async (id: number): Promise<Appointment> => {
  const response = await api.delete<Appointment>(`/appointments/${id}`);
  return response.data;
};

export const getAvailableTimeSlots = async (
  providerId: number, 
  date: string
): Promise<AvailableTimeSlotsResponse> => {
  const response = await api.get<AvailableTimeSlotsResponse>(
    `/appointments/available-slots/${providerId}`,
    { params: { date } }
  );
  return response.data;
};

// Service API calls
export const getAllServices = async (activeOnly: boolean = false): Promise<Service[]> => {
  const response = await api.get<Service[]>('/services', {
    params: { activeOnly }
  });
  return response.data;
};

export const getServiceById = async (id: number): Promise<Service> => {
  const response = await api.get<Service>(`/services/${id}`);
  return response.data;
};

export const createService = async (service: Service): Promise<Service> => {
  const response = await api.post<Service>('/services', service);
  return response.data;
};

export const updateService = async (id: number, service: Service): Promise<Service> => {
  const response = await api.put<Service>(`/services/${id}`, service);
  return response.data;
};

export const setServiceActiveStatus = async (id: number, active: boolean): Promise<Service> => {
  const response = await api.patch<Service>(`/services/${id}/status`, null, {
    params: { active }
  });
  return response.data;
};

// Time Slot Configuration API calls
export const getTimeSlotConfig = async (): Promise<TimeSlotConfig> => {
  const response = await api.get<TimeSlotConfig>('/time-slots/config');
  return response.data;
};

export const updateTimeSlotConfig = async (config: TimeSlotConfig): Promise<TimeSlotConfig> => {
  const response = await api.put<TimeSlotConfig>('/time-slots/config', config);
  return response.data;
};

export const createDefaultTimeSlotConfig = async (): Promise<TimeSlotConfig> => {
  const response = await api.post<TimeSlotConfig>('/time-slots/config/default');
  return response.data;
};

// Work Schedule API calls
export const getProviderSchedule = async (providerId: number): Promise<WeeklySchedule> => {
  const response = await api.get<WeeklySchedule>(`/work-schedules/${providerId}`);
  return response.data;
};

export const setProviderSchedule = async (request: SetWorkScheduleRequest): Promise<WeeklySchedule> => {
  const response = await api.put<WeeklySchedule>('/work-schedules', request);
  return response.data;
};

export const addScheduleException = async (exception: ScheduleException): Promise<ScheduleException> => {
  const response = await api.post<ScheduleException>('/work-schedules/exceptions', exception);
  return response.data;
};

export const updateScheduleException = async (
  id: number, 
  exception: ScheduleException
): Promise<ScheduleException> => {
  const response = await api.put<ScheduleException>(`/work-schedules/exceptions/${id}`, exception);
  return response.data;
};

export const deleteScheduleException = async (id: number): Promise<void> => {
  await api.delete(`/work-schedules/exceptions/${id}`);
};

export const getScheduleExceptionsForDateRange = async (
  providerId: number,
  startDate: string,
  endDate: string
): Promise<ScheduleException[]> => {
  const response = await api.get<ScheduleException[]>(`/work-schedules/exceptions/date-range`, {
    params: { providerId, startDate, endDate }
  });
  return response.data;
};

================
File: src/utils/axios.ts
================
import axios from 'axios';
import { getAccessToken, refreshAccessToken, clearTokens } from './tokenUtils';

// Create axios instance with default configs
const api = axios.create({
  baseURL: 'http://localhost:8080/api',
  headers: {
    'Content-Type': 'application/json',
  },
  withCredentials: true, // Important for CORS with credentials
});

// Add request interceptor to attach Authorization header with JWT token
api.interceptors.request.use(
  (config) => {
    const token = getAccessToken();
    if (token) {
      config.headers['Authorization'] = `Bearer ${token}`;
    }
    return config;
  },
  (error) => {
    return Promise.reject(error);
  }
);

// Add response interceptor to handle token refresh on 401 errors
api.interceptors.response.use(
  (response) => {
    return response;
  },
  async (error) => {
    const originalRequest = error.config;
    
    // If the error is 401 and we haven't already tried to refresh the token
    if (error.response?.status === 401 && !originalRequest._retry) {
      originalRequest._retry = true;
      
      try {
        // Attempt to refresh the token
        await refreshAccessToken();
        
        // Retry the original request with the new token
        const token = getAccessToken();
        if (token) {
          originalRequest.headers['Authorization'] = `Bearer ${token}`;
        }
        return api(originalRequest);
      } catch (refreshError) {
        // If refresh token is invalid, log the user out
        clearTokens();
        window.location.href = '/login';
        return Promise.reject(refreshError);
      }
    }
    
    return Promise.reject(error);
  }
);

export default api;

================
File: src/utils/tokenUtils.ts
================
import axios from 'axios';

// Cookie-based token management
const ACCESS_TOKEN_NAME = 'appointment_access_token';
const REFRESH_TOKEN_NAME = 'appointment_refresh_token';

// Helper to set a cookie with expiration
const setCookie = (name: string, value: string, days: number) => {
  const expires = new Date();
  expires.setTime(expires.getTime() + days * 24 * 60 * 60 * 1000);
  document.cookie = `${name}=${value};expires=${expires.toUTCString()};path=/;SameSite=Strict`;
};

// Helper to get a cookie by name
const getCookie = (name: string): string | null => {
  const match = document.cookie.match(new RegExp('(^| )' + name + '=([^;]+)'));
  return match ? match[2] : null;
};

// Helper to remove a cookie
const removeCookie = (name: string) => {
  document.cookie = `${name}=;expires=Thu, 01 Jan 1970 00:00:00 GMT;path=/;SameSite=Strict`;
};

// Store access token in a cookie (short-lived, 15 minutes)
export const setAccessToken = (token: string) => {
  setCookie(ACCESS_TOKEN_NAME, token, 0.01); // 15 minutes in days
};

// Store refresh token in a cookie (longer-lived, 30 days)
export const setRefreshToken = (token: string) => {
  setCookie(REFRESH_TOKEN_NAME, token, 30);
};

// Get the current access token
export const getAccessToken = (): string | null => {
  return getCookie(ACCESS_TOKEN_NAME);
};

// Get the current refresh token
export const getRefreshToken = (): string | null => {
  return getCookie(REFRESH_TOKEN_NAME);
};

// Clear both tokens (for logout)
export const clearTokens = () => {
  removeCookie(ACCESS_TOKEN_NAME);
  removeCookie(REFRESH_TOKEN_NAME);
};

// Use the refresh token to get a new access token
export const refreshAccessToken = async (): Promise<void> => {
  const refreshToken = getRefreshToken();
  
  if (!refreshToken) {
    throw new Error('No refresh token available');
  }
  
  try {
    const response = await axios.post('http://localhost:8080/api/auth/refreshtoken', {
      refreshToken,
    });
    
    const { accessToken, refreshToken: newRefreshToken } = response.data;
    
    setAccessToken(accessToken);
    
    // If a new refresh token is provided, update it
    if (newRefreshToken) {
      setRefreshToken(newRefreshToken);
    }
  } catch (error) {
    clearTokens();
    throw error;
  }
};

================
File: src/vite-env.d.ts
================
/// <reference types="vite/client" />

================
File: tsconfig.app.json
================
{
  "compilerOptions": {
    "tsBuildInfoFile": "./node_modules/.tmp/tsconfig.app.tsbuildinfo",
    "target": "ES2020",
    "useDefineForClassFields": true,
    "lib": ["ES2020", "DOM", "DOM.Iterable"],
    "module": "ESNext",
    "skipLibCheck": true,

    /* Bundler mode */
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "isolatedModules": true,
    "moduleDetection": "force",
    "noEmit": true,
    "jsx": "react-jsx",

    /* Linting */
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "noFallthroughCasesInSwitch": true,
    "noUncheckedSideEffectImports": true
  },
  "include": ["src"]
}

================
File: tsconfig.json
================
{
  "files": [],
  "references": [
    { "path": "./tsconfig.app.json" },
    { "path": "./tsconfig.node.json" }
  ]
}

================
File: tsconfig.node.json
================
{
  "compilerOptions": {
    "tsBuildInfoFile": "./node_modules/.tmp/tsconfig.node.tsbuildinfo",
    "target": "ES2022",
    "lib": ["ES2023"],
    "module": "ESNext",
    "skipLibCheck": true,

    /* Bundler mode */
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "isolatedModules": true,
    "moduleDetection": "force",
    "noEmit": true,

    /* Linting */
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "noFallthroughCasesInSwitch": true,
    "noUncheckedSideEffectImports": true
  },
  "include": ["vite.config.ts"]
}

================
File: vite.config.ts
================
import { defineConfig } from 'vite'
import react from '@vitejs/plugin-react'

// https://vite.dev/config/
export default defineConfig({
  plugins: [react()],
})

================
File: web.txt
================
This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2025-03-23T13:47:53.296Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

For more information about Repomix, visit: https://github.com/yamadashy/repomix

================================================================
Directory Structure
================================================================
.gitignore
eslint.config.js
index.html
LICENSE
package.json
public/vite.svg
README.md
src/App.css
src/App.tsx
src/assets/react.svg
src/components/auth/LoginForm.tsx
src/components/auth/RegisterForm.tsx
src/components/common/Navbar.tsx
src/components/common/ProtectedRoute.tsx
src/hooks/useAppointments.ts
src/hooks/useAuth.ts
src/main.tsx
src/pages/AppointmentDetailsPage.tsx
src/pages/AppointmentsPage.tsx
src/pages/DashboardPage.tsx
src/pages/EditAppointmentPage.tsx
src/pages/HomePage.tsx
src/pages/LoginPage.tsx
src/pages/NewAppointmentPage.tsx
src/pages/NotFoundPage.tsx
src/pages/RegisterPage.tsx
src/pages/ServiceManagementPage.tsx
src/store/appointmentSlice.ts
src/store/authSlice.ts
src/store/store.ts
src/types/appointment.ts
src/types/index.ts
src/utils/appointmentApi.ts
src/utils/axios.ts
src/utils/tokenUtils.ts
src/vite-env.d.ts
tsconfig.app.json
tsconfig.json
tsconfig.node.json
vite.config.ts

================================================================
Files
================================================================

================
File: .gitignore
================
# Logs
logs
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*
pnpm-debug.log*
lerna-debug.log*

node_modules
dist
dist-ssr
*.local

# Editor directories and files
.vscode/*
!.vscode/extensions.json
.idea
.DS_Store
*.suo
*.ntvs*
*.njsproj
*.sln
*.sw?

================
File: eslint.config.js
================
import js from '@eslint/js'
import globals from 'globals'
import reactHooks from 'eslint-plugin-react-hooks'
import reactRefresh from 'eslint-plugin-react-refresh'
import tseslint from 'typescript-eslint'

export default tseslint.config(
  { ignores: ['dist'] },
  {
    extends: [js.configs.recommended, ...tseslint.configs.recommended],
    files: ['**/*.{ts,tsx}'],
    languageOptions: {
      ecmaVersion: 2020,
      globals: globals.browser,
    },
    plugins: {
      'react-hooks': reactHooks,
      'react-refresh': reactRefresh,
    },
    rules: {
      ...reactHooks.configs.recommended.rules,
      'react-refresh/only-export-components': [
        'warn',
        { allowConstantExport: true },
      ],
    },
  },
)

================
File: index.html
================
<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="/vite.svg" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Vite + React + TS</title>
  </head>
  <body>
    <div id="root"></div>
    <script type="module" src="/src/main.tsx"></script>
  </body>
</html>

================
File: LICENSE
================
MIT License

Copyright (c) 2025 alexnistor0103

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

================
File: package.json
================
{
  "name": "vite-react-typescript-starter",
  "private": true,
  "version": "0.0.0",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "tsc -b && vite build",
    "lint": "eslint .",
    "preview": "vite preview"
  },
  "dependencies": {
    "@emotion/react": "^11.14.0",
    "@emotion/styled": "^11.14.0",
    "@mui/icons-material": "^5.17.1",
    "@mui/material": "^5.17.1",
    "@mui/x-date-pickers": "^7.28.0",
    "@reduxjs/toolkit": "^2.0.1",
    "axios": "^1.6.3",
    "date-fns": "^2.29.3",
    "react": "^18.2.0",
    "react-dom": "^18.2.0",
    "react-redux": "^9.0.4",
    "react-router-dom": "^6.21.1"
  },
  "devDependencies": {
    "@eslint/js": "^8.56.0",
    "@types/react": "^18.2.45",
    "@types/react-dom": "^18.2.18",
    "@vitejs/plugin-react": "^4.2.1",
    "eslint": "^8.56.0",
    "eslint-plugin-react-hooks": "^4.6.0",
    "eslint-plugin-react-refresh": "^0.4.5",
    "globals": "^13.24.0",
    "typescript": "^5.3.3",
    "typescript-eslint": "^7.0.0",
    "vite": "^5.0.10"
  }
}

================
File: public/vite.svg
================
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" role="img" class="iconify iconify--logos" width="31.88" height="32" preserveAspectRatio="xMidYMid meet" viewBox="0 0 256 257"><defs><linearGradient id="IconifyId1813088fe1fbc01fb466" x1="-.828%" x2="57.636%" y1="7.652%" y2="78.411%"><stop offset="0%" stop-color="#41D1FF"></stop><stop offset="100%" stop-color="#BD34FE"></stop></linearGradient><linearGradient id="IconifyId1813088fe1fbc01fb467" x1="43.376%" x2="50.316%" y1="2.242%" y2="89.03%"><stop offset="0%" stop-color="#FFEA83"></stop><stop offset="8.333%" stop-color="#FFDD35"></stop><stop offset="100%" stop-color="#FFA800"></stop></linearGradient></defs><path fill="url(#IconifyId1813088fe1fbc01fb466)" d="M255.153 37.938L134.897 252.976c-2.483 4.44-8.862 4.466-11.382.048L.875 37.958c-2.746-4.814 1.371-10.646 6.827-9.67l120.385 21.517a6.537 6.537 0 0 0 2.322-.004l117.867-21.483c5.438-.991 9.574 4.796 6.877 9.62Z"></path><path fill="url(#IconifyId1813088fe1fbc01fb467)" d="M185.432.063L96.44 17.501a3.268 3.268 0 0 0-2.634 3.014l-5.474 92.456a3.268 3.268 0 0 0 3.997 3.378l24.777-5.718c2.318-.535 4.413 1.507 3.936 3.838l-7.361 36.047c-.495 2.426 1.782 4.5 4.151 3.78l15.304-4.649c2.372-.72 4.652 1.36 4.15 3.788l-11.698 56.621c-.732 3.542 3.979 5.473 5.943 2.437l1.313-2.028l72.516-144.72c1.215-2.423-.88-5.186-3.54-4.672l-25.505 4.922c-2.396.462-4.435-1.77-3.759-4.114l16.646-57.705c.677-2.35-1.37-4.583-3.769-4.113Z"></path></svg>

================
File: README.md
================
# React + TypeScript + Vite

This template provides a minimal setup to get React working in Vite with HMR and some ESLint rules.

Currently, two official plugins are available:

- [@vitejs/plugin-react](https://github.com/vitejs/vite-plugin-react/blob/main/packages/plugin-react/README.md) uses [Babel](https://babeljs.io/) for Fast Refresh
- [@vitejs/plugin-react-swc](https://github.com/vitejs/vite-plugin-react-swc) uses [SWC](https://swc.rs/) for Fast Refresh

## Expanding the ESLint configuration

If you are developing a production application, we recommend updating the configuration to enable type-aware lint rules:

```js
export default tseslint.config({
  extends: [
    // Remove ...tseslint.configs.recommended and replace with this
    ...tseslint.configs.recommendedTypeChecked,
    // Alternatively, use this for stricter rules
    ...tseslint.configs.strictTypeChecked,
    // Optionally, add this for stylistic rules
    ...tseslint.configs.stylisticTypeChecked,
  ],
  languageOptions: {
    // other options...
    parserOptions: {
      project: ['./tsconfig.node.json', './tsconfig.app.json'],
      tsconfigRootDir: import.meta.dirname,
    },
  },
})
```

You can also install [eslint-plugin-react-x](https://github.com/Rel1cx/eslint-react/tree/main/packages/plugins/eslint-plugin-react-x) and [eslint-plugin-react-dom](https://github.com/Rel1cx/eslint-react/tree/main/packages/plugins/eslint-plugin-react-dom) for React-specific lint rules:

```js
// eslint.config.js
import reactX from 'eslint-plugin-react-x'
import reactDom from 'eslint-plugin-react-dom'

export default tseslint.config({
  plugins: {
    // Add the react-x and react-dom plugins
    'react-x': reactX,
    'react-dom': reactDom,
  },
  rules: {
    // other rules...
    // Enable its recommended typescript rules
    ...reactX.configs['recommended-typescript'].rules,
    ...reactDom.configs.recommended.rules,
  },
})
```

================
File: src/App.css
================
#root {
  max-width: 1280px;
  margin: 0 auto;
  padding: 2rem;
  text-align: center;
}

.logo {
  height: 6em;
  padding: 1.5em;
  will-change: filter;
  transition: filter 300ms;
}
.logo:hover {
  filter: drop-shadow(0 0 2em #646cffaa);
}
.logo.react:hover {
  filter: drop-shadow(0 0 2em #61dafbaa);
}

@keyframes logo-spin {
  from {
    transform: rotate(0deg);
  }
  to {
    transform: rotate(360deg);
  }
}

@media (prefers-reduced-motion: no-preference) {
  a:nth-of-type(2) .logo {
    animation: logo-spin infinite 20s linear;
  }
}

.card {
  padding: 2em;
}

.read-the-docs {
  color: #888;
}

================
File: src/App.tsx
================
// src/App.tsx
import React from 'react';
import { BrowserRouter, Routes, Route, Navigate } from 'react-router-dom';
import { Provider } from 'react-redux';
import { store } from './store/store';
import { ThemeProvider, createTheme, CssBaseline } from '@mui/material';
import { LocalizationProvider } from '@mui/x-date-pickers/LocalizationProvider';
import { AdapterDateFns } from '@mui/x-date-pickers/AdapterDateFns';
import Navbar from './components/common/Navbar';
import ProtectedRoute from './components/common/ProtectedRoute';

// Pages
import HomePage from './pages/HomePage';
import LoginPage from './pages/LoginPage';
import RegisterPage from './pages/RegisterPage';
import DashboardPage from './pages/DashboardPage';
import AppointmentsPage from './pages/AppointmentsPage';
import AppointmentDetailsPage from './pages/AppointmentDetailsPage';
import NewAppointmentPage from './pages/NewAppointmentPage';
import EditAppointmentPage from './pages/EditAppointmentPage';
import ServiceManagementPage from './pages/ServiceManagementPage';
import NotFoundPage from './pages/NotFoundPage';

// Create a theme
const theme = createTheme({
  palette: {
    primary: {
      main: '#8e44ad', // Purple color for Dasha's Nails
    },
    secondary: {
      main: '#e74c3c', // Red accent color
    },
  },
  typography: {
    fontFamily: [
      '"Poppins"',
      '"Roboto"',
      'sans-serif'
    ].join(','),
  }
});

function App() {
  return (
    <Provider store={store}>
      <ThemeProvider theme={theme}>
        <LocalizationProvider dateAdapter={AdapterDateFns}>
          <CssBaseline />
          <BrowserRouter>
            <Navbar />
            <Routes>
              {/* Public routes */}
              <Route path="/" element={<HomePage />} />
              <Route path="/login" element={<LoginPage />} />
              <Route path="/register" element={<RegisterPage />} />
              
              {/* Protected routes */}
              <Route
                path="/dashboard"
                element={
                  <ProtectedRoute>
                    <DashboardPage />
                  </ProtectedRoute>
                }
              />
              <Route
                path="/appointments"
                element={
                  <ProtectedRoute>
                    <AppointmentsPage />
                  </ProtectedRoute>
                }
              />
              <Route
                path="/appointments/:id"
                element={
                  <ProtectedRoute>
                    <AppointmentDetailsPage />
                  </ProtectedRoute>
                }
              />
              <Route
                path="/appointments/new"
                element={
                  <ProtectedRoute>
                    <NewAppointmentPage />
                  </ProtectedRoute>
                }
              />
              <Route
                path="/appointments/edit/:id"
                element={
                  <ProtectedRoute>
                    <EditAppointmentPage />
                  </ProtectedRoute>
                }
              />
              
              {/* Admin routes */}
              <Route
                path="/admin/services"
                element={
                  <ProtectedRoute>
                    <ServiceManagementPage />
                  </ProtectedRoute>
                }
              />
              
              {/* Error pages */}
              <Route path="/404" element={<NotFoundPage />} />
              <Route path="*" element={<Navigate to="/404" />} />
            </Routes>
          </BrowserRouter>
        </LocalizationProvider>
      </ThemeProvider>
    </Provider>
  );
}

export default App;

================
File: src/assets/react.svg
================
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" role="img" class="iconify iconify--logos" width="35.93" height="32" preserveAspectRatio="xMidYMid meet" viewBox="0 0 256 228"><path fill="#00D8FF" d="M210.483 73.824a171.49 171.49 0 0 0-8.24-2.597c.465-1.9.893-3.777 1.273-5.621c6.238-30.281 2.16-54.676-11.769-62.708c-13.355-7.7-35.196.329-57.254 19.526a171.23 171.23 0 0 0-6.375 5.848a155.866 155.866 0 0 0-4.241-3.917C100.759 3.829 77.587-4.822 63.673 3.233C50.33 10.957 46.379 33.89 51.995 62.588a170.974 170.974 0 0 0 1.892 8.48c-3.28.932-6.445 1.924-9.474 2.98C17.309 83.498 0 98.307 0 113.668c0 15.865 18.582 31.778 46.812 41.427a145.52 145.52 0 0 0 6.921 2.165a167.467 167.467 0 0 0-2.01 9.138c-5.354 28.2-1.173 50.591 12.134 58.266c13.744 7.926 36.812-.22 59.273-19.855a145.567 145.567 0 0 0 5.342-4.923a168.064 168.064 0 0 0 6.92 6.314c21.758 18.722 43.246 26.282 56.54 18.586c13.731-7.949 18.194-32.003 12.4-61.268a145.016 145.016 0 0 0-1.535-6.842c1.62-.48 3.21-.974 4.76-1.488c29.348-9.723 48.443-25.443 48.443-41.52c0-15.417-17.868-30.326-45.517-39.844Zm-6.365 70.984c-1.4.463-2.836.91-4.3 1.345c-3.24-10.257-7.612-21.163-12.963-32.432c5.106-11 9.31-21.767 12.459-31.957c2.619.758 5.16 1.557 7.61 2.4c23.69 8.156 38.14 20.213 38.14 29.504c0 9.896-15.606 22.743-40.946 31.14Zm-10.514 20.834c2.562 12.94 2.927 24.64 1.23 33.787c-1.524 8.219-4.59 13.698-8.382 15.893c-8.067 4.67-25.32-1.4-43.927-17.412a156.726 156.726 0 0 1-6.437-5.87c7.214-7.889 14.423-17.06 21.459-27.246c12.376-1.098 24.068-2.894 34.671-5.345a134.17 134.17 0 0 1 1.386 6.193ZM87.276 214.515c-7.882 2.783-14.16 2.863-17.955.675c-8.075-4.657-11.432-22.636-6.853-46.752a156.923 156.923 0 0 1 1.869-8.499c10.486 2.32 22.093 3.988 34.498 4.994c7.084 9.967 14.501 19.128 21.976 27.15a134.668 134.668 0 0 1-4.877 4.492c-9.933 8.682-19.886 14.842-28.658 17.94ZM50.35 144.747c-12.483-4.267-22.792-9.812-29.858-15.863c-6.35-5.437-9.555-10.836-9.555-15.216c0-9.322 13.897-21.212 37.076-29.293c2.813-.98 5.757-1.905 8.812-2.773c3.204 10.42 7.406 21.315 12.477 32.332c-5.137 11.18-9.399 22.249-12.634 32.792a134.718 134.718 0 0 1-6.318-1.979Zm12.378-84.26c-4.811-24.587-1.616-43.134 6.425-47.789c8.564-4.958 27.502 2.111 47.463 19.835a144.318 144.318 0 0 1 3.841 3.545c-7.438 7.987-14.787 17.08-21.808 26.988c-12.04 1.116-23.565 2.908-34.161 5.309a160.342 160.342 0 0 1-1.76-7.887Zm110.427 27.268a347.8 347.8 0 0 0-7.785-12.803c8.168 1.033 15.994 2.404 23.343 4.08c-2.206 7.072-4.956 14.465-8.193 22.045a381.151 381.151 0 0 0-7.365-13.322Zm-45.032-43.861c5.044 5.465 10.096 11.566 15.065 18.186a322.04 322.04 0 0 0-30.257-.006c4.974-6.559 10.069-12.652 15.192-18.18ZM82.802 87.83a323.167 323.167 0 0 0-7.227 13.238c-3.184-7.553-5.909-14.98-8.134-22.152c7.304-1.634 15.093-2.97 23.209-3.984a321.524 321.524 0 0 0-7.848 12.897Zm8.081 65.352c-8.385-.936-16.291-2.203-23.593-3.793c2.26-7.3 5.045-14.885 8.298-22.6a321.187 321.187 0 0 0 7.257 13.246c2.594 4.48 5.28 8.868 8.038 13.147Zm37.542 31.03c-5.184-5.592-10.354-11.779-15.403-18.433c4.902.192 9.899.29 14.978.29c5.218 0 10.376-.117 15.453-.343c-4.985 6.774-10.018 12.97-15.028 18.486Zm52.198-57.817c3.422 7.8 6.306 15.345 8.596 22.52c-7.422 1.694-15.436 3.058-23.88 4.071a382.417 382.417 0 0 0 7.859-13.026a347.403 347.403 0 0 0 7.425-13.565Zm-16.898 8.101a358.557 358.557 0 0 1-12.281 19.815a329.4 329.4 0 0 1-23.444.823c-7.967 0-15.716-.248-23.178-.732a310.202 310.202 0 0 1-12.513-19.846h.001a307.41 307.41 0 0 1-10.923-20.627a310.278 310.278 0 0 1 10.89-20.637l-.001.001a307.318 307.318 0 0 1 12.413-19.761c7.613-.576 15.42-.876 23.31-.876H128c7.926 0 15.743.303 23.354.883a329.357 329.357 0 0 1 12.335 19.695a358.489 358.489 0 0 1 11.036 20.54a329.472 329.472 0 0 1-11 20.722Zm22.56-122.124c8.572 4.944 11.906 24.881 6.52 51.026c-.344 1.668-.73 3.367-1.15 5.09c-10.622-2.452-22.155-4.275-34.23-5.408c-7.034-10.017-14.323-19.124-21.64-27.008a160.789 160.789 0 0 1 5.888-5.4c18.9-16.447 36.564-22.941 44.612-18.3ZM128 90.808c12.625 0 22.86 10.235 22.86 22.86s-10.235 22.86-22.86 22.86s-22.86-10.235-22.86-22.86s10.235-22.86 22.86-22.86Z"></path></svg>

================
File: src/components/auth/LoginForm.tsx
================
import React, { useState, useEffect } from 'react';
import { Link as RouterLink } from 'react-router-dom';
import { useAuth } from '../../hooks/useAuth';
import {
  Avatar,
  Button,
  TextField,
  Link,
  Grid,
  Box,
  Typography,
  Container,
  Paper,
  Alert,
  CircularProgress
} from '@mui/material';
import { LockOutlined } from '@mui/icons-material';

const LoginForm: React.FC = () => {
  const [email, setEmail] = useState('');
  const [password, setPassword] = useState('');
  const [formError, setFormError] = useState('');
  
  const { login, error, isLoading, clearError } = useAuth();
  
  // Clear API errors when component unmounts
  useEffect(() => {
    return () => {
      clearError();
    };
  }, [clearError]);
  
  // Update local error message when API error changes
  useEffect(() => {
    if (error) {
      setFormError(error);
    }
  }, [error]);
  
  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    
    // Form validation
    if (!email.trim()) {
      setFormError('Email-ul este obligatoriu');
      return;
    }
    
    if (!password) {
      setFormError('Parola este obligatorie');
      return;
    }
    
    // Clear previous errors
    setFormError('');
    
    // Attempt login
    await login({ email, password });
  };
  
  return (
    <Container component="main" maxWidth="xs">
      <Paper elevation={3} sx={{ mt: 8, p: 4, display: 'flex', flexDirection: 'column', alignItems: 'center' }}>
        <Avatar sx={{ m: 1, bgcolor: 'secondary.main' }}>
          <LockOutlined />
        </Avatar>
        
        <Typography component="h1" variant="h5">
          Conectare
        </Typography>
        
        {formError && (
          <Alert severity="error" sx={{ width: '100%', mt: 2 }}>
            {formError}
          </Alert>
        )}
        
        <Box component="form" onSubmit={handleSubmit} sx={{ mt: 1, width: '100%' }}>
          <TextField
            margin="normal"
            required
            fullWidth
            id="email"
            label="Adresă de Email"
            name="email"
            autoComplete="email"
            autoFocus
            value={email}
            onChange={(e) => setEmail(e.target.value)}
            disabled={isLoading}
          />
          
          <TextField
            margin="normal"
            required
            fullWidth
            name="password"
            label="Parolă"
            type="password"
            id="password"
            autoComplete="current-password"
            value={password}
            onChange={(e) => setPassword(e.target.value)}
            disabled={isLoading}
          />
          
          <Button
            type="submit"
            fullWidth
            variant="contained"
            sx={{ mt: 3, mb: 2, py: 1.5 }}
            disabled={isLoading}
          >
            {isLoading ? <CircularProgress size={24} /> : 'Conectare'}
          </Button>
          
          <Grid container justifyContent="flex-end">
            <Grid item>
              <Link component={RouterLink} to="/register" variant="body2">
                {"Nu ai un cont? Înregistrează-te"}
              </Link>
            </Grid>
          </Grid>
        </Box>
      </Paper>
    </Container>
  );
};

export default LoginForm;

================
File: src/components/auth/RegisterForm.tsx
================
import React, { useState, useEffect } from 'react';
import { Link as RouterLink } from 'react-router-dom';
import { useAuth } from '../../hooks/useAuth';
import { CountryEnum } from '../../types';
import {
  Avatar,
  Button,
  TextField,
  FormControl,
  InputLabel,
  Select,
  MenuItem,
  Link,
  Grid,
  Box,
  Typography,
  Container,
  Paper,
  Alert,
  CircularProgress
} from '@mui/material';
import { PersonAddOutlined } from '@mui/icons-material';

const RegisterForm: React.FC = () => {
  const [email, setEmail] = useState('');
  const [password, setPassword] = useState('');
  const [confirmPassword, setConfirmPassword] = useState('');
  const [firstName, setFirstName] = useState('');
  const [lastName, setLastName] = useState('');
  const [country, setCountry] = useState<CountryEnum>(CountryEnum.RO);
  const [formError, setFormError] = useState('');
  const [successMessage, setSuccessMessage] = useState('');
  
  const { register, error, isLoading, clearError } = useAuth();
  
  // Clear API errors when component unmounts
  useEffect(() => {
    return () => {
      clearError();
    };
  }, [clearError]);
  
  // Update local error message when API error changes
  useEffect(() => {
    if (error) {
      setFormError(error);
      setSuccessMessage('');
    }
  }, [error]);
  
  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    
    // Clear previous messages
    setFormError('');
    setSuccessMessage('');
    
    // Form validation
    if (!email.trim() || !password || !firstName.trim() || !lastName.trim()) {
      setFormError('Toate câmpurile sunt obligatorii');
      return;
    }
    
    if (password !== confirmPassword) {
      setFormError('Parolele nu se potrivesc');
      return;
    }
    
    if (password.length < 8) {
      setFormError('Parola trebuie să aibă cel puțin 8 caractere');
      return;
    }
    
    // Attempt registration
    const success = await register({
      email,
      password,
      firstName,
      lastName,
      country
    });
    
    if (success) {
      setSuccessMessage('Înregistrare reușită! Acum vă puteți conecta.');
      // Reset form
      setEmail('');
      setPassword('');
      setConfirmPassword('');
      setFirstName('');
      setLastName('');
    }
  };
  
  return (
    <Container component="main" maxWidth="xs">
      <Paper elevation={3} sx={{ mt: 8, p: 4, display: 'flex', flexDirection: 'column', alignItems: 'center' }}>
        <Avatar sx={{ m: 1, bgcolor: 'secondary.main' }}>
          <PersonAddOutlined />
        </Avatar>
        
        <Typography component="h1" variant="h5">
          Creați un cont
        </Typography>
        
        {formError && (
          <Alert severity="error" sx={{ width: '100%', mt: 2 }}>
            {formError}
          </Alert>
        )}
        
        {successMessage && (
          <Alert severity="success" sx={{ width: '100%', mt: 2 }}>
            {successMessage}
          </Alert>
        )}
        
        <Box component="form" onSubmit={handleSubmit} sx={{ mt: 3, width: '100%' }}>
          <Grid container spacing={2}>
            <Grid item xs={12}>
              <TextField
                required
                fullWidth
                id="email"
                label="Adresă de Email"
                name="email"
                autoComplete="email"
                value={email}
                onChange={(e) => setEmail(e.target.value)}
                disabled={isLoading}
              />
            </Grid>
            
            <Grid item xs={12} sm={6}>
              <TextField
                required
                fullWidth
                id="firstName"
                label="Prenume"
                name="firstName"
                autoComplete="given-name"
                value={firstName}
                onChange={(e) => setFirstName(e.target.value)}
                disabled={isLoading}
              />
            </Grid>
            
            <Grid item xs={12} sm={6}>
              <TextField
                required
                fullWidth
                id="lastName"
                label="Nume"
                name="lastName"
                autoComplete="family-name"
                value={lastName}
                onChange={(e) => setLastName(e.target.value)}
                disabled={isLoading}
              />
            </Grid>
            
            <Grid item xs={12}>
              <FormControl fullWidth>
                <InputLabel id="country-label">Țară</InputLabel>
                <Select
                  labelId="country-label"
                  id="country"
                  value={country}
                  label="Țară"
                  onChange={(e) => setCountry(e.target.value as CountryEnum)}
                  disabled={isLoading}
                >
                  <MenuItem value={CountryEnum.RO}>România</MenuItem>
                  <MenuItem value={CountryEnum.MD}>Moldova</MenuItem>
                </Select>
              </FormControl>
            </Grid>
            
            <Grid item xs={12}>
              <TextField
                required
                fullWidth
                name="password"
                label="Parolă"
                type="password"
                id="password"
                autoComplete="new-password"
                value={password}
                onChange={(e) => setPassword(e.target.value)}
                disabled={isLoading}
                inputProps={{ minLength: 8 }}
                helperText="Parola trebuie să aibă cel puțin 8 caractere"
              />
            </Grid>
            
            <Grid item xs={12}>
              <TextField
                required
                fullWidth
                name="confirmPassword"
                label="Confirmă Parola"
                type="password"
                id="confirmPassword"
                value={confirmPassword}
                onChange={(e) => setConfirmPassword(e.target.value)}
                disabled={isLoading}
              />
            </Grid>
          </Grid>
          
          <Button
            type="submit"
            fullWidth
            variant="contained"
            sx={{ mt: 3, mb: 2, py: 1.5 }}
            disabled={isLoading}
          >
            {isLoading ? <CircularProgress size={24} /> : 'Înregistrare'}
          </Button>
          
          <Grid container justifyContent="flex-end">
            <Grid item>
              <Link component={RouterLink} to="/login" variant="body2">
                Aveți deja un cont? Conectare
              </Link>
            </Grid>
          </Grid>
        </Box>
      </Paper>
    </Container>
  );
};

export default RegisterForm;

================
File: src/components/common/Navbar.tsx
================
// src/components/common/Navbar.tsx
import React, { useState } from 'react';
import { Link as RouterLink, useNavigate, useLocation } from 'react-router-dom';
import { useAuth } from '../../hooks/useAuth';
import {
  AppBar,
  Toolbar,
  Typography,
  Button,
  IconButton,
  Menu,
  MenuItem,
  Avatar,
  Box,
  Drawer,
  List,
  ListItem,
  ListItemButton,
  ListItemIcon,
  ListItemText,
  Divider,
  Collapse,
  useMediaQuery,
  useTheme
} from '@mui/material';
import {
  Menu as MenuIcon,
  AccountCircle,
  Dashboard,
  Event,
  Home,
  Login,
  Logout,
  Person,
  PersonAdd,
  ExpandLess,
  ExpandMore,
  AdminPanelSettings,
  Spa,
  Schedule
} from '@mui/icons-material';

const Navbar: React.FC = () => {
  const { isAuthenticated, user, logout } = useAuth();
  const navigate = useNavigate();
  const location = useLocation();
  const theme = useTheme();
  const isMobile = useMediaQuery(theme.breakpoints.down('sm'));
  
  const [anchorEl, setAnchorEl] = useState<null | HTMLElement>(null);
  const [drawerOpen, setDrawerOpen] = useState(false);
  const [adminMenuOpen, setAdminMenuOpen] = useState(false);
  
  // Check if user has admin role
  const isAdmin = user?.roles && user.roles.includes('ROLE_ADMIN');
  
  const handleMenu = (event: React.MouseEvent<HTMLElement>) => {
    setAnchorEl(event.currentTarget);
  };

  const handleClose = () => {
    setAnchorEl(null);
  };
  
  const handleDrawerToggle = () => {
    setDrawerOpen(!drawerOpen);
  };
  
  const toggleAdminMenu = () => {
    setAdminMenuOpen(!adminMenuOpen);
  };

  const handleLogout = async () => {
    handleClose();
    await logout();
    navigate('/');
  };
  
  const handleNavigation = (path: string) => {
    navigate(path);
    handleClose();
    setDrawerOpen(false);
  };
  
  // Drawer content
  const drawerContent = (
    <Box sx={{ width: 250 }} role="presentation">
      <List>
        <ListItem>
          <Typography variant="h6" color="primary">
            Dasha's Nails
          </Typography>
        </ListItem>
        <Divider />
        
        <ListItem>
          <ListItemButton onClick={() => handleNavigation('/')}>
            <ListItemIcon>
              <Home />
            </ListItemIcon>
            <ListItemText primary="Prezentare" />
          </ListItemButton>
        </ListItem>
        
        {isAuthenticated ? (
          <>
            <ListItem>
              <ListItemButton onClick={() => handleNavigation('/dashboard')}>
                <ListItemIcon>
                  <Dashboard />
                </ListItemIcon>
                <ListItemText primary="Acasă" />
              </ListItemButton>
            </ListItem>
            
            <ListItem>
              <ListItemButton onClick={() => handleNavigation('/appointments')}>
                <ListItemIcon>
                  <Event />
                </ListItemIcon>
                <ListItemText primary="Programările mele" />
              </ListItemButton>
            </ListItem>
            
            <ListItem>
              <ListItemButton onClick={() => handleNavigation('/appointments/new')}>
                <ListItemIcon>
                  <Schedule />
                </ListItemIcon>
                <ListItemText primary="Programare nouă" />
              </ListItemButton>
            </ListItem>
            
            <ListItem>
              <ListItemButton onClick={() => handleNavigation('/profile')}>
                <ListItemIcon>
                  <Person />
                </ListItemIcon>
                <ListItemText primary="Profil" />
              </ListItemButton>
            </ListItem>
            
            {isAdmin && (
              <>
                <ListItem>
                  <ListItemButton onClick={toggleAdminMenu}>
                    <ListItemIcon>
                      <AdminPanelSettings />
                    </ListItemIcon>
                    <ListItemText primary="Administrare" />
                    {adminMenuOpen ? <ExpandLess /> : <ExpandMore />}
                  </ListItemButton>
                </ListItem>
                <Collapse in={adminMenuOpen} timeout="auto" unmountOnExit>
                  <List component="div" disablePadding>
                    <ListItemButton 
                      sx={{ pl: 4 }}
                      onClick={() => handleNavigation('/admin/services')}
                    >
                      <ListItemIcon>
                        <Spa />
                      </ListItemIcon>
                      <ListItemText primary="Servicii" />
                    </ListItemButton>
                  </List>
                </Collapse>
              </>
            )}
            
            <Divider />
            
            <ListItem>
              <ListItemButton onClick={handleLogout}>
                <ListItemIcon>
                  <Logout />
                </ListItemIcon>
                <ListItemText primary="Deconectare" />
              </ListItemButton>
            </ListItem>
          </>
        ) : (
          <>
            <ListItem>
              <ListItemButton onClick={() => handleNavigation('/login')}>
                <ListItemIcon>
                  <Login />
                </ListItemIcon>
                <ListItemText primary="Conectare" />
              </ListItemButton>
            </ListItem>
            
            <ListItem>
              <ListItemButton onClick={() => handleNavigation('/register')}>
                <ListItemIcon>
                  <PersonAdd />
                </ListItemIcon>
                <ListItemText primary="Înregistrare" />
              </ListItemButton>
            </ListItem>
          </>
        )}
      </List>
    </Box>
  );

  return (
    <>
      <AppBar position="static">
        <Toolbar>
          {isMobile && (
            <IconButton
              edge="start"
              color="inherit"
              aria-label="menu"
              onClick={handleDrawerToggle}
              sx={{ mr: 2 }}
            >
              <MenuIcon />
            </IconButton>
          )}
          
          <Typography
            variant="h6"
            component={RouterLink}
            to="/"
            sx={{ 
              flexGrow: 1, 
              textDecoration: 'none', 
              color: 'inherit',
              fontWeight: 800
            }}
          >
            Dasha's Nails
          </Typography>
          
          {!isMobile && (
            <Box sx={{ display: 'flex' }}>
              <Button 
                color="inherit" 
                component={RouterLink} 
                to="/"
              >
                Prezentare
              </Button>
              
              {isAuthenticated ? (
                <>
                  <Button 
                    color="inherit" 
                    component={RouterLink} 
                    to="/dashboard"
                  >
                    Acasă
                  </Button>
                  
                  <Button 
                    color="inherit" 
                    component={RouterLink} 
                    to="/appointments"
                  >
                    Programări
                  </Button>
                  
                  {isAdmin && (
                    <Button
                      color="inherit"
                      onClick={handleMenu}
                      endIcon={<ExpandMore />}
                    >
                      Admin
                    </Button>
                  )}
                </>
              ) : null}
            </Box>
          )}
          
          {isAuthenticated ? (
            <div>
              <IconButton
                aria-label="account of current user"
                aria-controls="menu-appbar"
                aria-haspopup="true"
                onClick={handleMenu}
                color="inherit"
              >
                {user?.firstName ? (
                  <Avatar sx={{ width: 32, height: 32, bgcolor: 'secondary.main' }}>
                    {user.firstName[0]}
                  </Avatar>
                ) : (
                  <AccountCircle />
                )}
              </IconButton>
              
              <Menu
                id="menu-appbar"
                anchorEl={anchorEl}
                anchorOrigin={{
                  vertical: 'bottom',
                  horizontal: 'right',
                }}
                keepMounted
                transformOrigin={{
                  vertical: 'top',
                  horizontal: 'right',
                }}
                open={Boolean(anchorEl)}
                onClose={handleClose}
              >
                <MenuItem onClick={() => handleNavigation('/profile')}>
                  Profil
                </MenuItem>
                
                {isAdmin && !isMobile && (
                  <>
                    <Divider />
                    <MenuItem 
                      onClick={() => handleNavigation('/admin/services')}
                    >
                      Gestionare Servicii
                    </MenuItem>
                  </>
                )}
                
                <Divider />
                <MenuItem onClick={handleLogout}>Deconectare</MenuItem>
              </Menu>
            </div>
          ) : (
            !isMobile && (
              <div>
                <Button 
                  color="inherit" 
                  component={RouterLink} 
                  to="/login"
                >
                  Conectare
                </Button>
                <Button 
                  color="inherit" 
                  component={RouterLink} 
                  to="/register"
                >
                  Înregistrează-te
                </Button>
              </div>
            )
          )}
        </Toolbar>
      </AppBar>
      
      <Drawer
        anchor="left"
        open={drawerOpen}
        onClose={handleDrawerToggle}
      >
        {drawerContent}
      </Drawer>
    </>
  );
};

export default Navbar

================
File: src/components/common/ProtectedRoute.tsx
================
import React from 'react';
import { Navigate, useLocation } from 'react-router-dom';
import { useAuth } from '../../hooks/useAuth';
import { CircularProgress, Box } from '@mui/material';

interface ProtectedRouteProps {
  children: React.ReactNode;
}

const ProtectedRoute: React.FC<ProtectedRouteProps> = ({ children }) => {
  const { isAuthenticated, isLoading } = useAuth();
  const location = useLocation();

  if (isLoading) {
    return (
      <Box sx={{ display: 'flex', justifyContent: 'center', alignItems: 'center', height: '100vh' }}>
        <CircularProgress />
      </Box>
    );
  }

  if (!isAuthenticated) {
    return <Navigate to="/login" state={{ from: location }} replace />;
  }

  return <>{children}</>;
};

export default ProtectedRoute;

================
File: src/hooks/useAppointments.ts
================
// src/hooks/useAppointments.ts
import { useDispatch, useSelector } from 'react-redux';
import { 
  fetchClientAppointments, 
  fetchProviderAppointments,
  fetchAppointmentById,
  createNewAppointment,
  updateExistingAppointment,
  cancelExistingAppointment,
  fetchAvailableTimeSlots,
  fetchServices,
  resetAppointmentError,
  resetCurrentAppointment,
  clearAvailableTimeSlots
} from '../store/appointmentSlice';
import { RootState, AppDispatch } from '../store/store';
import { 
  CreateAppointmentRequest, 
  UpdateAppointmentRequest 
} from '../types/appointment';

export const useAppointments = () => {
  const dispatch = useDispatch<AppDispatch>();
  const { 
    appointments, 
    currentAppointment, 
    services,
    availableTimeSlots,
    isLoading, 
    error 
  } = useSelector((state: RootState) => state.appointments);
  
  // Client appointments
  const getClientAppointments = async (clientId: number) => {
    try {
      await dispatch(fetchClientAppointments(clientId)).unwrap();
      return true;
    } catch (error) {
      return false;
    }
  };
  
  // Provider appointments
  const getProviderAppointments = async (providerId: number) => {
    try {
      await dispatch(fetchProviderAppointments(providerId)).unwrap();
      return true;
    } catch (error) {
      return false;
    }
  };
  
  // Get specific appointment
  const getAppointment = async (id: number) => {
    try {
      await dispatch(fetchAppointmentById(id)).unwrap();
      return true;
    } catch (error) {
      return false;
    }
  };
  
  // Create appointment
  const createAppointment = async (request: CreateAppointmentRequest) => {
    try {
      const result = await dispatch(createNewAppointment(request)).unwrap();
      return result;
    } catch (error) {
      return null;
    }
  };
  
  // Update appointment
  const updateAppointment = async (id: number, request: UpdateAppointmentRequest) => {
    try {
      const result = await dispatch(updateExistingAppointment({ id, request })).unwrap();
      return result;
    } catch (error) {
      return null;
    }
  };
  
  // Cancel appointment
  const cancelAppointment = async (id: number) => {
    try {
      const result = await dispatch(cancelExistingAppointment(id)).unwrap();
      return result;
    } catch (error) {
      return null;
    }
  };
  
  // Get available time slots
  const getAvailableTimeSlots = async (providerId: number, date: string) => {
    try {
      await dispatch(fetchAvailableTimeSlots({ providerId, date })).unwrap();
      return true;
    } catch (error) {
      return false;
    }
  };
  
  // Get services
  const getServices = async (activeOnly: boolean = true) => {
    try {
      await dispatch(fetchServices(activeOnly)).unwrap();
      return true;
    } catch (error) {
      return false;
    }
  };
  
  // Reset current appointment
  const resetAppointment = () => {
    dispatch(resetCurrentAppointment());
  };
  
  // Clear available time slots
  const clearTimeSlots = () => {
    dispatch(clearAvailableTimeSlots());
  };
  
  // Clear error
  const clearError = () => {
    dispatch(resetAppointmentError());
  };
  
  return {
    appointments,
    currentAppointment,
    services,
    availableTimeSlots,
    isLoading,
    error,
    getClientAppointments,
    getProviderAppointments,
    getAppointment,
    createAppointment,
    updateAppointment,
    cancelAppointment,
    getAvailableTimeSlots,
    getServices,
    resetAppointment,
    clearTimeSlots,
    clearError
  };
};

================
File: src/hooks/useAuth.ts
================
import { useEffect } from 'react';
import { useDispatch, useSelector } from 'react-redux';
import { useNavigate } from 'react-router-dom';
import { 
  login as loginAction, 
  register as registerAction,
  logout as logoutAction,
  getCurrentUser, 
  resetAuthError
} from '../store/authSlice';
import { RootState, AppDispatch } from '../store/store';
import { LoginRequest, RegisterRequest } from '../types';
import { getAccessToken } from '../utils/tokenUtils';

export const useAuth = () => {
  const dispatch = useDispatch<AppDispatch>(); // Use AppDispatch type here
  const navigate = useNavigate();
  const auth = useSelector((state: RootState) => state.auth);
  
  // Check authentication status on mount
  useEffect(() => {
    const token = getAccessToken();
    
    if (token && !auth.user) {
      // If we have a token but no user data, try to fetch the user
      dispatch(getCurrentUser());
    }
  }, [dispatch, auth.user]);
  
  // Login function
  const login = async (credentials: LoginRequest) => {
    try {
      await dispatch(loginAction(credentials)).unwrap();
      navigate('/dashboard');
      return true;
    } catch (error) {
      return false;
    }
  };
  
  // Register function
  const register = async (userData: RegisterRequest) => {
    try {
      await dispatch(registerAction(userData)).unwrap();
      return true;
    } catch (error) {
      return false;
    }
  };
  
  // Logout function
  const logout = async () => {
    await dispatch(logoutAction());
    navigate('/');
  };
  
  // Clear authentication errors
  const clearError = () => {
    dispatch(resetAuthError());
  };
  
  return {
    user: auth.user,
    isAuthenticated: auth.isAuthenticated,
    isLoading: auth.isLoading,
    error: auth.error,
    login,
    register,
    logout,
    clearError
  };
};

================
File: src/main.tsx
================
import { StrictMode } from 'react'
import { createRoot } from 'react-dom/client'
import './index.css'
import App from './App.tsx'

const rootElement = document.getElementById('root');

if (!rootElement) {
  console.error('Root element not found');
} else {
  const root = createRoot(rootElement);
  root.render(
    <StrictMode>
      <App />
    </StrictMode>
  );
  console.log('React app mounted successfully');
}

================
File: src/pages/AppointmentDetailsPage.tsx
================
// src/pages/AppointmentDetailsPage.tsx
import React, { useEffect } from 'react';
import { useParams, useNavigate } from 'react-router-dom';
import { useAppointments } from '../hooks/useAppointments';
import { format, parseISO } from 'date-fns';
import { AppointmentStatusEnum } from '../types/appointment';
import {
  Container,
  Typography,
  Box,
  Paper,
  Grid,
  Button,
  Chip,
  Divider,
  CircularProgress,
  Alert,
  IconButton
} from '@mui/material';
import {
  ArrowBack as ArrowBackIcon,
  CalendarToday as CalendarIcon,
  AccessTime as TimeIcon,
  Person as PersonIcon,
  Edit as EditIcon,
  Cancel as CancelIcon
} from '@mui/icons-material';

const AppointmentDetailsPage: React.FC = () => {
  const { id } = useParams<{ id: string }>();
  const navigate = useNavigate();
  const { currentAppointment, getAppointment, cancelAppointment, isLoading, error } = useAppointments();
  
  useEffect(() => {
    if (id) {
      getAppointment(parseInt(id));
    }
  }, [id, getAppointment]);
  
  // Format date for display
  const formatDateTime = (dateTime: string) => {
    try {
      const parsedDate = parseISO(dateTime);
      return format(parsedDate, 'dd MMMM yyyy, HH:mm');
    } catch (error) {
      return dateTime;
    }
  };
  
  // Handle cancel appointment
  const handleCancelAppointment = async () => {
    if (!currentAppointment) return;
    
    if (window.confirm('Sunteți sigur că doriți să anulați această programare?')) {
      const result = await cancelAppointment(currentAppointment.id);
      if (result) {
        // Refresh the appointment data
        getAppointment(currentAppointment.id);
      }
    }
  };
  
  // Get status chip color
  const getStatusColor = (status: AppointmentStatusEnum) => {
    switch (status) {
      case AppointmentStatusEnum.PENDING:
        return 'warning';
      case AppointmentStatusEnum.CONFIRMED:
        return 'success';
      case AppointmentStatusEnum.CANCELLED:
        return 'error';
      case AppointmentStatusEnum.COMPLETED:
        return 'primary';
      case AppointmentStatusEnum.NO_SHOW:
        return 'error';
      default:
        return 'default';
    }
  };
  
  // Check if appointment can be cancelled or edited
  const canModify = currentAppointment && 
    (currentAppointment.status === AppointmentStatusEnum.PENDING || 
     currentAppointment.status === AppointmentStatusEnum.CONFIRMED);
  
  return (
    <Container maxWidth="md" sx={{ mt: 4, mb: 4 }}>
      <Box sx={{ mb: 3, display: 'flex', alignItems: 'center' }}>
        <IconButton 
          aria-label="back" 
          onClick={() => navigate('/appointments')}
          sx={{ mr: 2 }}
        >
          <ArrowBackIcon />
        </IconButton>
        <Typography variant="h4" component="h1">
          Detalii programare
        </Typography>
      </Box>
      
      {error && (
        <Alert severity="error" sx={{ mb: 3 }}>
          {error}
        </Alert>
      )}
      
      {isLoading ? (
        <Box sx={{ display: 'flex', justifyContent: 'center', p: 4 }}>
          <CircularProgress />
        </Box>
      ) : !currentAppointment ? (
        <Alert severity="warning">
          Nu s-au putut găsi detaliile programării.
        </Alert>
      ) : (
        <Paper sx={{ p: 3 }}>
          <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', mb: 3 }}>
            <Typography variant="h5">
              Programare #{currentAppointment.id}
            </Typography>
            <Chip 
              label={currentAppointment.status} 
              color={getStatusColor(currentAppointment.status)}
            />
          </Box>
          
          <Grid container spacing={3}>
            <Grid item xs={12} md={6}>
              <Box sx={{ display: 'flex', alignItems: 'center', mb: 2 }}>
                <CalendarIcon sx={{ mr: 2, color: 'primary.main' }} />
                <Box>
                  <Typography variant="body2" color="text.secondary">
                    Data și ora
                  </Typography>
                  <Typography variant="body1">
                    {formatDateTime(currentAppointment.startTime)}
                  </Typography>
                </Box>
              </Box>
              
              <Box sx={{ display: 'flex', alignItems: 'center', mb: 2 }}>
                <TimeIcon sx={{ mr: 2, color: 'primary.main' }} />
                <Box>
                  <Typography variant="body2" color="text.secondary">
                    Durată
                  </Typography>
                  <Typography variant="body1">
                    {Math.round(
                      (new Date(currentAppointment.endTime).getTime() - 
                      new Date(currentAppointment.startTime).getTime()) / 60000
                    )} minute
                  </Typography>
                </Box>
              </Box>
            </Grid>
            
            <Grid item xs={12} md={6}>
              <Box sx={{ display: 'flex', alignItems: 'center', mb: 2 }}>
                <PersonIcon sx={{ mr: 2, color: 'primary.main' }} />
                <Box>
                  <Typography variant="body2" color="text.secondary">
                    Specialist
                  </Typography>
                  <Typography variant="body1">
                    {currentAppointment.providerName}
                  </Typography>
                </Box>
              </Box>
            </Grid>
            
            <Grid item xs={12}>
              <Divider sx={{ my: 2 }} />
              <Typography variant="h6" gutterBottom>
                Servicii
              </Typography>
              
              {currentAppointment.services.map((service) => (
                <Box 
                  key={service.id}
                  sx={{ 
                    display: 'flex', 
                    justifyContent: 'space-between',
                    mb: 1
                  }}
                >
                  <Typography variant="body1">
                    {service.name} ({service.durationMinutes} min)
                  </Typography>
                  <Typography variant="body1">
                    {service.price} lei
                  </Typography>
                </Box>
              ))}
              
              <Box 
                sx={{ 
                  display: 'flex', 
                  justifyContent: 'space-between',
                  mt: 2,
                  pt: 2,
                  borderTop: '1px solid',
                  borderColor: 'divider'
                }}
              >
                <Typography variant="subtitle1" fontWeight="bold">
                  Total
                </Typography>
                <Typography variant="subtitle1" fontWeight="bold">
                  {currentAppointment.totalPrice} lei
                </Typography>
              </Box>
            </Grid>
            
            {currentAppointment.notes && (
              <Grid item xs={12}>
                <Divider sx={{ my: 2 }} />
                <Typography variant="h6" gutterBottom>
                  Note
                </Typography>
                <Typography variant="body1">
                  {currentAppointment.notes}
                </Typography>
              </Grid>
            )}
            
            {canModify && (
              <Grid item xs={12}>
                <Divider sx={{ my: 2 }} />
                <Box sx={{ display: 'flex', gap: 2, justifyContent: 'flex-end' }}>
                  <Button
                    variant="outlined"
                    startIcon={<EditIcon />}
                    onClick={() => navigate(`/appointments/edit/${currentAppointment.id}`)}
                  >
                    Modifică
                  </Button>
                  <Button
                    variant="outlined"
                    color="error"
                    startIcon={<CancelIcon />}
                    onClick={handleCancelAppointment}
                  >
                    Anulează
                  </Button>
                </Box>
              </Grid>
            )}
          </Grid>
        </Paper>
      )}
    </Container>
  )
}

export default AppointmentDetailsPage

================
File: src/pages/AppointmentsPage.tsx
================
// src/pages/AppointmentsPage.tsx
import React, { useEffect, useState } from 'react';
import { useAuth } from '../hooks/useAuth';
import { useAppointments } from '../hooks/useAppointments';
import { AppointmentStatusEnum } from '../types/appointment';
import { format, parseISO } from 'date-fns';
import {
  Container,
  Typography,
  Box,
  Paper,
  Tabs,
  Tab,
  Divider,
  List,
  ListItem,
  ListItemText,
  ListItemSecondaryAction,
  IconButton,
  Button,
  Chip,
  Dialog,
  DialogTitle,
  DialogContent,
  DialogContentText,
  DialogActions,
  CircularProgress,
  Alert,
  Grid
} from '@mui/material';
import { 
  CalendarToday as CalendarIcon,
  AccessTime as TimeIcon,
  Edit as EditIcon,
  Cancel as CancelIcon,
  Info as InfoIcon
} from '@mui/icons-material';

interface TabPanelProps {
  children?: React.ReactNode;
  index: number;
  value: number;
}

const TabPanel = (props: TabPanelProps) => {
  const { children, value, index, ...other } = props;

  return (
    <div
      role="tabpanel"
      hidden={value !== index}
      id={`appointment-tabpanel-${index}`}
      aria-labelledby={`appointment-tab-${index}`}
      {...other}
    >
      {value === index && (
        <Box sx={{ p: 3 }}>
          {children}
        </Box>
      )}
    </div>
  );
};

const AppointmentsPage: React.FC = () => {
  const { user } = useAuth();
  const { 
    appointments, 
    getClientAppointments, 
    cancelAppointment,
    isLoading, 
    error 
  } = useAppointments();
  
  const [tabValue, setTabValue] = useState(0);
  const [cancelDialogOpen, setCancelDialogOpen] = useState(false);
  const [selectedAppointmentId, setSelectedAppointmentId] = useState<number | null>(null);
  
  // Fetch appointments on mount
  useEffect(() => {
    if (user?.id) {
      getClientAppointments(user.id);
    }
  }, [user?.id, getClientAppointments]);
  
  const handleTabChange = (_event: React.SyntheticEvent, newValue: number) => {
    setTabValue(newValue);
  };
  
  // Filter appointments by status
  const upcomingAppointments = appointments.filter(
    apt => apt.status === AppointmentStatusEnum.PENDING || 
          apt.status === AppointmentStatusEnum.CONFIRMED
  );
  
  const pastAppointments = appointments.filter(
    apt => apt.status === AppointmentStatusEnum.COMPLETED ||
          apt.status === AppointmentStatusEnum.CANCELLED ||
          apt.status === AppointmentStatusEnum.NO_SHOW
  );
  
  // Format date for display
  const formatDateTime = (dateTime: string) => {
    try {
      const parsedDate = parseISO(dateTime);
      return format(parsedDate, 'dd MMM yyyy, HH:mm');
    } catch (error) {
      return dateTime; // Fallback to original string if parsing fails
    }
  };
  
  // Handle appointment cancellation
  const handleCancelClick = (id: number) => {
    setSelectedAppointmentId(id);
    setCancelDialogOpen(true);
  };
  
  const handleCancelConfirm = async () => {
    if (selectedAppointmentId) {
      await cancelAppointment(selectedAppointmentId);
      setCancelDialogOpen(false);
      setSelectedAppointmentId(null);
    }
  };
  
  const handleCancelDialogClose = () => {
    setCancelDialogOpen(false);
    setSelectedAppointmentId(null);
  };
  
  // Get status chip color
  const getStatusColor = (status: AppointmentStatusEnum) => {
    switch (status) {
      case AppointmentStatusEnum.PENDING:
        return 'warning';
      case AppointmentStatusEnum.CONFIRMED:
        return 'success';
      case AppointmentStatusEnum.CANCELLED:
        return 'error';
      case AppointmentStatusEnum.COMPLETED:
        return 'primary';
      case AppointmentStatusEnum.NO_SHOW:
        return 'error';
      default:
        return 'default';
    }
  };
  
  return (
    <Container maxWidth="md" sx={{ mt: 4, mb: 4 }}>
      <Typography variant="h4" component="h1" gutterBottom>
        Programările mele
      </Typography>

      {error && (
        <Alert severity="error" sx={{ mb: 2 }}>
          {error}
        </Alert>
      )}

      <Paper sx={{ width: '100%', mb: 2 }}>
        <Tabs
          value={tabValue}
          onChange={handleTabChange}
          indicatorColor="primary"
          textColor="primary"
          centered
        >
          <Tab label={`Programări viitoare (${upcomingAppointments.length})`} />
          <Tab label={`Istoric programări (${pastAppointments.length})`} />
        </Tabs>

        <Divider />

        {isLoading ? (
          <Box sx={{ display: 'flex', justifyContent: 'center', p: 4 }}>
            <CircularProgress />
          </Box>
        ) : (
          <>
            <TabPanel value={tabValue} index={0}>
              {upcomingAppointments.length > 0 ? (
                <List>
                  {upcomingAppointments.map((appointment) => (
                    <React.Fragment key={appointment.id}>
                      <ListItem alignItems="flex-start">
                        <Grid container spacing={2}>
                          <Grid item xs={12} sm={8}>
                            <Box sx={{ display: 'flex', alignItems: 'center', mb: 1 }}>
                              <CalendarIcon fontSize="small" sx={{ mr: 1, color: 'primary.main' }} />
                              <Typography variant="subtitle1">
                                {formatDateTime(appointment.startTime)}
                              </Typography>
                            </Box>
                            
                            <Box sx={{ display: 'flex', alignItems: 'center', mb: 1 }}>
                              <TimeIcon fontSize="small" sx={{ mr: 1, color: 'primary.main' }} />
                              <Typography variant="body2">
                                Durată: {
                                  Math.round(
                                    (new Date(appointment.endTime).getTime() - 
                                    new Date(appointment.startTime).getTime()) / 60000
                                  )
                                } minute
                              </Typography>
                            </Box>
                            
                            <Typography variant="subtitle2" gutterBottom>
                              Servicii:
                            </Typography>
                            <Box sx={{ ml: 2 }}>
                              {appointment.services.map((service) => (
                                <Typography key={service.id} variant="body2">
                                  • {service.name} ({service.durationMinutes} min) - {service.price} lei
                                </Typography>
                              ))}
                            </Box>
                            
                            {appointment.notes && (
                              <Box sx={{ mt: 1 }}>
                                <Typography variant="body2" color="text.secondary">
                                  Note: {appointment.notes}
                                </Typography>
                              </Box>
                            )}
                          </Grid>
                          
                          <Grid item xs={12} sm={4}>
                            <Box sx={{ display: 'flex', flexDirection: 'column', alignItems: 'flex-end' }}>
                              <Chip 
                                label={appointment.status} 
                                color={getStatusColor(appointment.status)}
                                size="small"
                                sx={{ mb: 2 }}
                              />
                              
                              <Typography variant="subtitle1" sx={{ mb: 2 }}>
                                Total: {appointment.totalPrice} lei
                              </Typography>
                              
                              <Button
                                variant="outlined"
                                color="primary"
                                size="small"
                                startIcon={<EditIcon />}
                                sx={{ mb: 1 }}
                                href={`/appointments/edit/${appointment.id}`}
                              >
                                Modifică
                              </Button>
                              
                              <Button
                                variant="outlined"
                                color="error"
                                size="small"
                                startIcon={<CancelIcon />}
                                onClick={() => handleCancelClick(appointment.id)}
                              >
                                Anulează
                              </Button>
                            </Box>
                          </Grid>
                        </Grid>
                      </ListItem>
                      <Divider component="li" />
                    </React.Fragment>
                  ))}
                </List>
              ) : (
                <Box sx={{ p: 4, textAlign: 'center' }}>
                  <Typography variant="body1" color="text.secondary">
                    Nu aveți programări viitoare
                  </Typography>
                  <Button
                    variant="contained"
                    color="primary"
                    sx={{ mt: 2 }}
                    href="/appointments/new"
                  >
                    Creați o programare nouă
                  </Button>
                </Box>
              )}
            </TabPanel>
            
            <TabPanel value={tabValue} index={1}>
              {pastAppointments.length > 0 ? (
                <List>
                  {pastAppointments.map((appointment) => (
                    <React.Fragment key={appointment.id}>
                      <ListItem alignItems="flex-start">
                        <ListItemText
                          primary={
                            <Box sx={{ display: 'flex', alignItems: 'center', justifyContent: 'space-between' }}>
                              <Typography variant="subtitle1">
                                {formatDateTime(appointment.startTime)}
                              </Typography>
                              <Chip 
                                label={appointment.status} 
                                color={getStatusColor(appointment.status)}
                                size="small"
                              />
                            </Box>
                          }
                          secondary={
                            <>
                              <Typography variant="body2" component="span" display="block">
                                Servicii: {appointment.services.map(s => s.name).join(', ')}
                              </Typography>
                              <Typography variant="body2" component="span" display="block">
                                Total: {appointment.totalPrice} lei
                              </Typography>
                            </>
                          }
                        />
                        <ListItemSecondaryAction>
                          <IconButton 
                            edge="end" 
                            aria-label="details"
                            href={`/appointments/${appointment.id}`}
                          >
                            <InfoIcon />
                          </IconButton>
                        </ListItemSecondaryAction>
                      </ListItem>
                      <Divider component="li" />
                    </React.Fragment>
                  ))}
                </List>
              ) : (
                <Box sx={{ p: 4, textAlign: 'center' }}>
                  <Typography variant="body1" color="text.secondary">
                    Nu aveți programări anterioare
                  </Typography>
                </Box>
              )}
            </TabPanel>
          </>
        )}
      </Paper>
      
      {/* Create new appointment button */}
      <Box sx={{ display: 'flex', justifyContent: 'center', mt: 4 }}>
        <Button
          variant="contained"
          color="primary"
          size="large"
          href="/appointments/new"
        >
          Programare nouă
        </Button>
      </Box>
      
      {/* Cancel appointment confirmation dialog */}
      <Dialog
        open={cancelDialogOpen}
        onClose={handleCancelDialogClose}
      >
        <DialogTitle>Confirmare anulare programare</DialogTitle>
        <DialogContent>
          <DialogContentText>
            Sunteți sigur că doriți să anulați această programare? Această acțiune nu poate fi anulată.
          </DialogContentText>
        </DialogContent>
        <DialogActions>
          <Button onClick={handleCancelDialogClose} color="primary">
            Renunță
          </Button>
          <Button onClick={handleCancelConfirm} color="error" autoFocus>
            Anulează programarea
          </Button>
        </DialogActions>
      </Dialog>
    </Container>
  )
}

export default  AppointmentsPage

================
File: src/pages/DashboardPage.tsx
================
import React from 'react';
import { useAuth } from '../hooks/useAuth';
import {
  Container,
  Typography,
  Box,
  Grid,
  Paper,
  Card,
  CardContent,
  CardHeader,
  Divider,
  Button,
  List,
  ListItem,
  ListItemText,
  ListItemAvatar,
  Avatar
} from '@mui/material';
import { 
  Event as EventIcon,
  Today as TodayIcon,
  History as HistoryIcon,
  Add as AddIcon
} from '@mui/icons-material';

const DashboardPage: React.FC = () => {
  const { user } = useAuth();
  
  // This would typically come from an API call
  const upcomingAppointments = [
    {
      id: 1,
      service: 'Unghii simple',
      date: '2025-03-25',
      time: '10:00 AM',
      provider: 'Daria'
    },
    {
      id: 2,
      service: 'Unghii gel',
      date: '2025-04-01',
      time: '2:30 PM',
      provider: 'Daria'
    }
  ];
  
  return (
    <Container maxWidth="lg" sx={{ mt: 4, mb: 4 }}>
      <Box sx={{ mb: 4 }}>
        <Typography variant="h4" component="h1" gutterBottom>
          Acasa
        </Typography>
        <Typography variant="subtitle1" color="text.secondary">
          Bine ati revenit, {user?.firstName || 'Guest'}!
        </Typography>
      </Box>
      
      <Grid container spacing={3}>
        {/* Summary Cards */}
        <Grid item xs={12} md={4}>
          <Card sx={{ height: '100%' }}>
            <CardHeader title="Urmeaza" />
            <CardContent>
              <Box sx={{ display: 'flex', alignItems: 'center' }}>
                <Avatar sx={{ bgcolor: 'primary.main', mr: 2 }}>
                  <TodayIcon />
                </Avatar>
                <Typography variant="h4">{upcomingAppointments.length}</Typography>
              </Box>
              <Typography variant="body2" color="text.secondary" sx={{ mt: 1 }}>
                Aveti {upcomingAppointments.length} programari
              </Typography>
            </CardContent>
          </Card>
        </Grid>
        
        <Grid item xs={12} md={4}>
          <Card sx={{ height: '100%' }}>
            <CardHeader title="Istoric" />
            <CardContent>
              <Box sx={{ display: 'flex', alignItems: 'center' }}>
                <Avatar sx={{ bgcolor: 'secondary.main', mr: 2 }}>
                  <HistoryIcon />
                </Avatar>
                <Typography variant="h4">0</Typography>
              </Box>
              <Typography variant="body2" color="text.secondary" sx={{ mt: 1 }}>
                Ati avut 0 programari luna aceasta
              </Typography>
            </CardContent>
          </Card>
        </Grid>
        
        <Grid item xs={12} md={4}>
          <Card sx={{ height: '100%' }}>
            <CardHeader title="Actiuni rapide" />
            <CardContent>
              <Button 
                variant="contained" 
                startIcon={<AddIcon />}
                fullWidth
                sx={{ mb: 2 }}
              >
                Faceti o programare
              </Button>
              <Button 
                variant="outlined"
                fullWidth
              >
                Vezi toate programarile
              </Button>
            </CardContent>
          </Card>
        </Grid>
        
        {/* Upcoming Appointments */}
        <Grid item xs={12}>
          <Paper sx={{ p: 2 }}>
            <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', mb: 2 }}>
              <Typography variant="h6" component="h2">
                Programari viitoare
              </Typography>
              <Button
                variant="text"
                color="primary"
                size="small"
              >
                Vezi tot
              </Button>
            </Box>
            <Divider sx={{ mb: 2 }} />
            
            {upcomingAppointments.length > 0 ? (
              <List sx={{ width: '100%' }}>
                {upcomingAppointments.map((appointment) => (
                  <React.Fragment key={appointment.id}>
                    <ListItem alignItems="flex-start">
                      <ListItemAvatar>
                        <Avatar sx={{ bgcolor: 'primary.main' }}>
                          <EventIcon />
                        </Avatar>
                      </ListItemAvatar>
                      <ListItemText
                        primary={appointment.service}
                        secondary={
                          <>
                            <Typography
                              component="span"
                              variant="body2"
                              color="text.primary"
                            >
                              {appointment.date} la {appointment.time}
                            </Typography>
                            {` — cu ${appointment.provider}`}
                          </>
                        }
                      />
                      <Box>
                        <Button size="small" color="primary">
                          Reprogramati
                        </Button>
                        <Button size="small" color="error">
                          Anulati
                        </Button>
                      </Box>
                    </ListItem>
                    <Divider variant="inset" component="li" />
                  </React.Fragment>
                ))}
              </List>
            ) : (
              <Box sx={{ py: 4, textAlign: 'center' }}>
                <Typography color="text.secondary">
                  Nu aveti programari in viitor
                </Typography>
                <Button
                  variant="contained"
                  color="primary"
                  startIcon={<AddIcon />}
                  sx={{ mt: 2 }}
                >
                  Faceti prima programare
                </Button>
              </Box>
            )}
          </Paper>
        </Grid>
      </Grid>
    </Container>
  );
};

export default DashboardPage;

================
File: src/pages/EditAppointmentPage.tsx
================
import React, { useEffect, useState } from 'react';
import { useParams, useNavigate } from 'react-router-dom';
import { useAuth } from '../hooks/useAuth';
import { useAppointments } from '../hooks/useAppointments';
import { Service, UpdateAppointmentRequest } from '../types/appointment';
import { format, parseISO, addDays } from 'date-fns';
import {
  Container,
  Typography,
  Box,
  Paper,
  Grid,
  Button,
  Checkbox,
  TextField,
  FormControlLabel,
  FormGroup,
  FormControl,
  RadioGroup,
  Radio,
  FormLabel,
  CircularProgress,
  Alert,
  IconButton,
  Divider,
  Card,
  CardContent,
  CardActionArea
} from '@mui/material';
import { DatePicker } from '@mui/x-date-pickers/DatePicker';
import { AdapterDateFns } from '@mui/x-date-pickers/AdapterDateFns';
import { LocalizationProvider } from '@mui/x-date-pickers/LocalizationProvider';
import {
  ArrowBack as ArrowBackIcon,
  CalendarToday as CalendarIcon,
  AccessTime as TimeIcon,
  CheckCircle as CheckCircleIcon,
  Save as SaveIcon
} from '@mui/icons-material';

const EditAppointmentPage: React.FC = () => {
  const { id } = useParams<{ id: string }>();
  const navigate = useNavigate();
  const { user } = useAuth();
  const { 
    currentAppointment, 
    services, 
    availableTimeSlots,
    getAppointment,
    getServices,
    getAvailableTimeSlots,
    updateAppointment,
    clearTimeSlots,
    isLoading, 
    error 
  } = useAppointments();
  
  // Form state
  const [selectedServices, setSelectedServices] = useState<Service[]>([]);
  const [selectedDate, setSelectedDate] = useState<Date | null>(null);
  const [selectedTimeSlot, setSelectedTimeSlot] = useState<string | null>(null);
  const [notes, setNotes] = useState('');
  const [formErrors, setFormErrors] = useState<{ [key: string]: string }>({});
  const [hasChanges, setHasChanges] = useState(false);
  
  // Computed values
  const totalDuration = selectedServices.reduce((sum, service) => sum + service.durationMinutes, 0);
  const totalPrice = selectedServices.reduce((sum, service) => sum + service.price, 0);
  
  // Fetch appointment and services on mount
  useEffect(() => {
    if (id) {
      getAppointment(parseInt(id));
      getServices(true);
    }
  }, [id, getAppointment, getServices]);
  
  // Initialize form with appointment data
  useEffect(() => {
    if (currentAppointment && services.length > 0) {
      // Find the service objects that match the appointment's services
      const appointmentServices = services.filter(service => 
        currentAppointment.services.some(s => s.id === service.id)
      );
      
      setSelectedServices(appointmentServices);
      
      // Parse the appointment start time to get the date
      const appointmentDate = parseISO(currentAppointment.startTime);
      setSelectedDate(appointmentDate);
      
      // Use the original start time string
      setSelectedTimeSlot(currentAppointment.startTime);
      
      // Set notes
      setNotes(currentAppointment.notes || '');
      
      // Fetch available time slots for the appointment date
      if (user?.id) {
        const formattedDate = format(appointmentDate, 'yyyy-MM-dd');
        // TODO: Replace with actual provider ID
        const providerId = currentAppointment.providerId;
        getAvailableTimeSlots(providerId, formattedDate);
      }
    }
  }, [currentAppointment, services, user?.id, getAvailableTimeSlots]);
  
  // When date changes, fetch available time slots
  useEffect(() => {
    if (selectedDate && currentAppointment) {
      // Only if the date has changed from the original
      const originalDate = parseISO(currentAppointment.startTime);
      if (format(selectedDate, 'yyyy-MM-dd') !== format(originalDate, 'yyyy-MM-dd')) {
        // Clear previous time slots and selected time
        clearTimeSlots();
        setSelectedTimeSlot(null);
        
        // Format date for API
        const formattedDate = format(selectedDate, 'yyyy-MM-dd');
        
        // Use the appointment's provider ID
        const providerId = currentAppointment.providerId;
        
        getAvailableTimeSlots(providerId, formattedDate);
        
        setHasChanges(true);
      }
    }
  }, [selectedDate, currentAppointment, clearTimeSlots, getAvailableTimeSlots]);
  
  // Check for changes to track if form has been modified
  useEffect(() => {
    if (currentAppointment) {
      const servicesChanged = selectedServices.length !== currentAppointment.services.length ||
        !selectedServices.every(service => 
          currentAppointment.services.some(s => s.id === service.id)
        );
      
      const timeChanged = selectedTimeSlot !== currentAppointment.startTime;
      
      const notesChanged = notes !== (currentAppointment.notes || '');
      
      setHasChanges(servicesChanged || timeChanged || notesChanged);
    }
  }, [currentAppointment, selectedServices, selectedTimeSlot, notes]);
  
  // Handle service selection
  const handleServiceToggle = (service: Service) => {
    setSelectedServices((prev) => {
      const serviceIndex = prev.findIndex(s => s.id === service.id);
      if (serviceIndex === -1) {
        // Add service
        return [...prev, service];
      } else {
        // Remove service
        return prev.filter(s => s.id !== service.id);
      }
    });
  };
  
  // Handle time slot selection
  const handleTimeSlotSelect = (timeSlot: string) => {
    setSelectedTimeSlot(timeSlot);
  };
  
  // Handle form submission
  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    
    // Validate form
    const errors: { [key: string]: string } = {};
    
    if (selectedServices.length === 0) {
      errors.services = 'Selectați cel puțin un serviciu';
    }
    
    if (!selectedTimeSlot) {
      errors.time = 'Selectați o oră';
    }
    
    // If there are errors, show them and don't proceed
    if (Object.keys(errors).length > 0) {
      setFormErrors(errors);
      return;
    }
    
    // Clear any previous errors
    setFormErrors({});
    
    if (!currentAppointment || !selectedTimeSlot) return;
    
    // Prepare update data
    const updateData: UpdateAppointmentRequest = {
      id: currentAppointment.id,
      startTime: selectedTimeSlot,
      serviceIds: selectedServices.map(service => service.id),
      notes: notes.trim() || undefined
    };
    
    const result = await updateAppointment(currentAppointment.id, updateData);
    
    if (result) {
      navigate(`/appointments/${currentAppointment.id}`);
    }
  };
  
  // Format date for display
  const formatDateTime = (dateTime: string) => {
    try {
      const parsedDate = parseISO(dateTime);
      return format(parsedDate, 'HH:mm');
    } catch (error) {
      return dateTime;
    }
  };
  
  return (
    <Container maxWidth="md" sx={{ mt: 4, mb: 6 }}>
      <Box sx={{ mb: 3, display: 'flex', alignItems: 'center' }}>
        <IconButton 
          aria-label="back" 
          onClick={() => navigate(`/appointments/${id}`)}
          sx={{ mr: 2 }}
        >
          <ArrowBackIcon />
        </IconButton>
        <Typography variant="h4" component="h1">
          Modificare programare
        </Typography>
      </Box>
      
      {error && (
        <Alert severity="error" sx={{ mb: 3 }}>
          {error}
        </Alert>
      )}
      
      {isLoading && !currentAppointment ? (
        <Box sx={{ display: 'flex', justifyContent: 'center', p: 4 }}>
          <CircularProgress />
        </Box>
      ) : !currentAppointment ? (
        <Alert severity="warning">
          Nu s-au putut găsi detaliile programării.
        </Alert>
      ) : (
        <Paper sx={{ p: 3 }}>
          <form onSubmit={handleSubmit}>
            <Grid container spacing={4}>
              {/* Services selection */}
              <Grid item xs={12}>
                <Typography variant="h6" gutterBottom>
                  Servicii
                </Typography>
                
                {formErrors.services && (
                  <Alert severity="error" sx={{ mb: 2 }}>
                    {formErrors.services}
                  </Alert>
                )}
                
                <Grid container spacing={2}>
                  {services.map((service) => (
                    <Grid item xs={12} sm={6} md={4} key={service.id}>
                      <Card 
                        variant="outlined"
                        sx={{ 
                          height: '100%',
                          border: selectedServices.some(s => s.id === service.id) 
                            ? '2px solid' 
                            : '1px solid',
                          borderColor: selectedServices.some(s => s.id === service.id)
                            ? 'primary.main'
                            : 'divider'
                        }}
                      >
                        <CardActionArea 
                          onClick={() => handleServiceToggle(service)}
                          sx={{ height: '100%', display: 'flex', flexDirection: 'column', alignItems: 'stretch' }}
                        >
                          <CardContent sx={{ flexGrow: 1 }}>
                            <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'flex-start' }}>
                              <Typography variant="h6" component="div">
                                {service.name}
                              </Typography>
                              {selectedServices.some(s => s.id === service.id) && (
                                <CheckCircleIcon color="primary" />
                              )}
                            </Box>
                            
                            {service.description && (
                              <Typography variant="body2" color="text.secondary" sx={{ mt: 1 }}>
                                {service.description}
                              </Typography>
                            )}
                            
                            <Box sx={{ display: 'flex', justifyContent: 'space-between', mt: 2 }}>
                              <Typography variant="body2" color="text.secondary">
                                <TimeIcon fontSize="small" sx={{ verticalAlign: 'middle', mr: 0.5 }} />
                                {service.durationMinutes} min
                              </Typography>
                              <Typography variant="subtitle1">
                                {service.price} lei
                              </Typography>
                            </Box>
                          </CardContent>
                        </CardActionArea>
                      </Card>
                    </Grid>
                  ))}
                </Grid>
                
                {selectedServices.length > 0 && (
                  <Paper variant="outlined" sx={{ mt: 3, p: 2 }}>
                    <Typography variant="subtitle1" gutterBottom>
                      Servicii selectate:
                    </Typography>
                    {selectedServices.map((service) => (
                      <Box key={service.id} sx={{ display: 'flex', justifyContent: 'space-between', mb: 1 }}>
                        <Typography variant="body1">
                          {service.name} ({service.durationMinutes} min)
                        </Typography>
                        <Typography variant="body1">
                          {service.price} lei
                        </Typography>
                      </Box>
                    ))}
                    <Divider sx={{ my: 1 }} />
                    <Box sx={{ display: 'flex', justifyContent: 'space-between' }}>
                      <Typography variant="subtitle1">
                        Durată totală: {totalDuration} min
                      </Typography>
                      <Typography variant="subtitle1">
                        Total: {totalPrice} lei
                      </Typography>
                    </Box>
                  </Paper>
                )}
              </Grid>
              
              {/* Date and time selection */}
              <Grid item xs={12}>
                <Typography variant="h6" gutterBottom>
                  Data și ora
                </Typography>
                
                <Grid container spacing={3}>
                  <Grid item xs={12} md={6}>
                    <LocalizationProvider dateAdapter={AdapterDateFns}>
                      <DatePicker 
                        label="Data programării"
                        value={selectedDate}
                        onChange={(newDate) => setSelectedDate(newDate)}
                        disablePast
                        maxDate={addDays(new Date(), 30)}
                        slotProps={{ 
                          textField: { 
                            fullWidth: true,
                            error: !!formErrors.date,
                            helperText: formErrors.date
                          } 
                        }}
                      />
                    </LocalizationProvider>
                  </Grid>
                </Grid>
                
                <Typography variant="subtitle1" sx={{ mt: 3, mb: 2 }}>
                  Ore disponibile:
                </Typography>
                
                {isLoading && !availableTimeSlots.length ? (
                  <Box sx={{ display: 'flex', justifyContent: 'center', p: 2 }}>
                    <CircularProgress />
                  </Box>
                ) : availableTimeSlots.length === 0 ? (
                  <Alert severity="info">
                    {selectedDate && format(selectedDate, 'yyyy-MM-dd') !== format(parseISO(currentAppointment.startTime), 'yyyy-MM-dd')
                      ? 'Nu există ore disponibile pentru data selectată. Vă rugăm să selectați o altă dată.'
                      : 'Ora programării curente va fi păstrată. Selectați o altă dată pentru a vedea orele disponibile.'}
                  </Alert>
                ) : (
                  <>
                    {formErrors.time && (
                      <Alert severity="error" sx={{ mb: 2 }}>
                        {formErrors.time}
                      </Alert>
                    )}
                    
                    <FormControl component="fieldset">
                      <RadioGroup 
                        value={selectedTimeSlot || ''}
                        onChange={(e) => handleTimeSlotSelect(e.target.value)}
                      >
                        <Grid container spacing={2}>
                          {availableTimeSlots
                            .filter(slot => slot.available || slot.startTime === currentAppointment.startTime)
                            .map((timeSlot, index) => (
                              <Grid item xs={6} sm={4} md={3} key={index}>
                                <FormControlLabel
                                  value={timeSlot.startTime}
                                  control={<Radio />}
                                  label={formatDateTime(timeSlot.startTime)}
                                  sx={{
                                    display: 'flex',
                                    border: '1px solid',
                                    borderColor: 'divider',
                                    borderRadius: 1,
                                    p: 1,
                                    width: '100%',
                                    m: 0
                                  }}
                                />
                              </Grid>
                            ))}
                        </Grid>
                      </RadioGroup>
                    </FormControl>
                  </>
                )}
              </Grid>
              
              {/* Notes */}
              <Grid item xs={12}>
                <Typography variant="h6" gutterBottom>
                  Note (opțional)
                </Typography>
                <TextField
                  multiline
                  rows={3}
                  fullWidth
                  placeholder="Adăugați orice informații suplimentare pentru programarea dvs."
                  value={notes}
                  onChange={(e) => setNotes(e.target.value)}
                  inputProps={{ maxLength: 500 }}
                />
              </Grid>
              
              {/* Submit button */}
              <Grid item xs={12}>
                <Box sx={{ display: 'flex', justifyContent: 'flex-end', mt: 2 }}>
                  <Button
                    type="button"
                    variant="outlined"
                    onClick={() => navigate(`/appointments/${id}`)}
                    sx={{ mr: 2 }}
                  >
                    Anulează
                  </Button>
                  <Button
                    type="submit"
                    variant="contained"
                    color="primary"
                    startIcon={<SaveIcon />}
                    disabled={isLoading || !hasChanges}
                  >
                    {isLoading ? <CircularProgress size={24} /> : 'Salvează modificările'}
                  </Button>
                </Box>
              </Grid>
            </Grid>
          </form>
        </Paper>
      )}
    </Container>
  );
};

export default EditAppointmentPage;

================
File: src/pages/HomePage.tsx
================
import React from 'react';
import { useNavigate } from 'react-router-dom';
import { useAuth } from '../hooks/useAuth';
import {
  Box,
  Button,
  Container,
  Typography,
  Grid,
  Card,
  CardContent,
  CardActions,
  CardMedia,
  Stack
} from '@mui/material';
import { 
  EventAvailable, 
  CalendarToday, 
  AccessTime, 
  Notifications 
} from '@mui/icons-material';

const HomePage: React.FC = () => {
  const { isAuthenticated } = useAuth();
  const navigate = useNavigate();

  const handleGetStarted = () => {
    if (isAuthenticated) {
      navigate('/dashboard');
    } else {
      navigate('/register');
    }
  };

  return (
    <Box>
      {/* Hero Section */}
      <Box
        sx={{
          bgcolor: 'primary.main',
          color: 'white',
          py: 8,
          mb: 6
        }}
      >
        <Container maxWidth="lg">
          <Grid container spacing={4} alignItems="center">
            <Grid item xs={12} md={6}>
              <Typography variant="h3" component="h1" gutterBottom>
                Cele mai bune unghii vin la pachet cu cel mai bun serviciu de programări
              </Typography>
              <Typography variant="h6" paragraph>
                Rezervă serviciile tale pentru unghii online, gestionează-ți programul și primește reminder-uri. Platforma noastră face programarea simplă.
              </Typography>
              <Stack direction="row" spacing={2} sx={{ mt: 4 }}>
                <Button 
                  variant="contained" 
                  size="large" 
                  color="secondary"
                  onClick={handleGetStarted}
                >
                  Începe
                </Button>
                {!isAuthenticated && (
                  <Button 
                    variant="outlined" 
                    size="large" 
                    color="inherit"
                    onClick={() => navigate('/login')}
                  >
                    Conectare
                  </Button>
                )}
              </Stack>
            </Grid>
            <Grid item xs={12} md={6}>
              <Box
                component="img"
                src="/api/placeholder/600/400"
                alt="Programare salon de unghii"
                sx={{
                  width: '100%',
                  borderRadius: 2,
                  boxShadow: 3
                }}
              />
            </Grid>
          </Grid>
        </Container>
      </Box>

      {/* Features Section */}
      <Container maxWidth="lg" sx={{ mb: 8 }}>
        <Typography variant="h4" component="h2" align="center" gutterBottom>
          Caracteristicile Noastre
        </Typography>
        <Typography variant="subtitle1" align="center" color="text.secondary" paragraph>
          Tot ce ai nevoie pentru a-ți gestiona programările
        </Typography>

        <Grid container spacing={4} sx={{ mt: 4 }}>
          <Grid item xs={12} sm={6} md={3}>
            <Card sx={{ height: '100%' }}>
              <Box sx={{ p: 2, display: 'flex', justifyContent: 'center' }}>
                <EventAvailable fontSize="large" color="primary" />
              </Box>
              <CardContent>
                <Typography variant="h6" component="h3" align="center">
                  Rezervare Ușoară
                </Typography>
                <Typography variant="body2" color="text.secondary" align="center">
                  Programează întâlniri cu tehnicianul tău preferat de unghii în câteva secunde.
                </Typography>
              </CardContent>
            </Card>
          </Grid>

          <Grid item xs={12} sm={6} md={3}>
            <Card sx={{ height: '100%' }}>
              <Box sx={{ p: 2, display: 'flex', justifyContent: 'center' }}>
                <CalendarToday fontSize="large" color="primary" />
              </Box>
              <CardContent>
                <Typography variant="h6" component="h3" align="center">
                  Gestionează Calendarul
                </Typography>
                <Typography variant="body2" color="text.secondary" align="center">
                  Vizualizează și gestionează toate programările tale într-un singur loc.
                </Typography>
              </CardContent>
            </Card>
          </Grid>

          <Grid item xs={12} sm={6} md={3}>
            <Card sx={{ height: '100%' }}>
              <Box sx={{ p: 2, display: 'flex', justifyContent: 'center' }}>
                <AccessTime fontSize="large" color="primary" />
              </Box>
              <CardContent>
                <Typography variant="h6" component="h3" align="center">
                  Disponibilitate în Timp Real
                </Typography>
                <Typography variant="body2" color="text.secondary" align="center">
                  Vezi disponibilitatea în timp real a tehnicienilor și serviciilor.
                </Typography>
              </CardContent>
            </Card>
          </Grid>

          <Grid item xs={12} sm={6} md={3}>
            <Card sx={{ height: '100%' }}>
              <Box sx={{ p: 2, display: 'flex', justifyContent: 'center' }}>
                <Notifications fontSize="large" color="primary" />
              </Box>
              <CardContent>
                <Typography variant="h6" component="h3" align="center">
                  Reminder-uri
                </Typography>
                <Typography variant="body2" color="text.secondary" align="center">
                  Primește reminder-uri automate înainte de programare.
                </Typography>
              </CardContent>
            </Card>
          </Grid>
        </Grid>
      </Container>

      {/* CTA Section */}
      <Box sx={{ bgcolor: 'grey.100', py: 6 }}>
        <Container maxWidth="md">
          <Typography variant="h4" align="center" gutterBottom>
            Ești gata să simplifici programările la salonul de unghii?
          </Typography>
          <Typography variant="subtitle1" align="center" color="text.secondary" paragraph>
            Alătură-te miilor de clienți mulțumiți care se bucură deja de platforma noastră.
          </Typography>
          <Box sx={{ display: 'flex', justifyContent: 'center', mt: 4 }}>
            <Button 
              variant="contained" 
              size="large" 
              color="primary"
              onClick={handleGetStarted}
            >
              {isAuthenticated ? 'Mergi la Panou de Control' : 'Înregistrează-te Acum'}
            </Button>
          </Box>
        </Container>
      </Box>
    </Box>
  );
};

export default HomePage;

================
File: src/pages/LoginPage.tsx
================
import React, { useEffect } from 'react';
import { useNavigate, useLocation } from 'react-router-dom';
import { Container } from '@mui/material';
import LoginForm from '../components/auth/LoginForm';
import { useAuth } from '../hooks/useAuth';

// Define a type for the location state
interface LocationState {
  from?: {
    pathname: string;
  };
}

const LoginPage: React.FC = () => {
  const { isAuthenticated } = useAuth();
  const navigate = useNavigate();
  const location = useLocation();
  
  // Get the desired redirect path from location state or default to dashboard
  const from = (location.state as LocationState)?.from?.pathname || '/dashboard';
  
  // Redirect if already authenticated
  useEffect(() => {
    if (isAuthenticated) {
      navigate(from, { replace: true });
    }
  }, [isAuthenticated, navigate, from]);
  
  return (
    <Container>
      <LoginForm />
    </Container>
  );
};

export default LoginPage;

================
File: src/pages/NewAppointmentPage.tsx
================
// src/pages/NewAppointmentPage.tsx
import React, { useEffect, useState } from 'react';
import { useNavigate } from 'react-router-dom';
import { useAuth } from '../hooks/useAuth';
import { useAppointments } from '../hooks/useAppointments';
import { Service } from '../types/appointment';
import { format, addDays, parseISO } from 'date-fns';
import {
  Container,
  Typography,
  Box,
  Paper,
  Stepper,
  Step,
  StepLabel,
  Grid,
  TextField,
  Button,
  FormControlLabel,
  Checkbox,
  Radio,
  RadioGroup,
  FormControl,
  FormGroup,
  FormLabel,
  InputAdornment,
  CircularProgress,
  Alert,
  Card,
  CardContent,
  CardMedia,
  CardActionArea,
  Divider
} from '@mui/material';
import { DatePicker } from '@mui/x-date-pickers/DatePicker';
import { AdapterDateFns } from '@mui/x-date-pickers/AdapterDateFns';
import { LocalizationProvider } from '@mui/x-date-pickers/LocalizationProvider';
import { 
  CalendarMonth as CalendarIcon,
  AccessTime as TimeIcon,
  Event as EventIcon,
  CheckCircle as CheckCircleIcon
} from '@mui/icons-material';

// Step components for the stepper
const steps = ['Selectare servicii', 'Selectare dată și oră', 'Confirmare'];

const NewAppointmentPage: React.FC = () => {
  const navigate = useNavigate();
  const { user } = useAuth();
  const { 
    services, 
    availableTimeSlots,
    getServices, 
    getAvailableTimeSlots,
    createAppointment,
    isLoading, 
    error,
    clearTimeSlots 
  } = useAppointments();
  
  // State for the appointment creation process
  const [activeStep, setActiveStep] = useState(0);
  const [selectedServices, setSelectedServices] = useState<Service[]>([]);
  const [selectedDate, setSelectedDate] = useState<Date | null>(null);
  const [selectedTimeSlot, setSelectedTimeSlot] = useState<string | null>(null);
  const [notes, setNotes] = useState('');
  const [formErrors, setFormErrors] = useState<{ [key: string]: string }>({});
  
  // Computed values
  const totalDuration = selectedServices.reduce((sum, service) => sum + service.durationMinutes, 0);
  const totalPrice = selectedServices.reduce((sum, service) => sum + service.price, 0);
  
  // Fetch services on mount
  useEffect(() => {
    getServices(true);
  }, [getServices]);
  
  // When date changes, fetch available time slots
  useEffect(() => {
    if (selectedDate && user?.id) {
      // Clear previous time slots and selected time
      clearTimeSlots();
      setSelectedTimeSlot(null);
      
      // Format date for API
      const formattedDate = format(selectedDate, 'yyyy-MM-dd');
      
      // TODO: Replace with actual provider ID, for now using 1
      const providerId = 1;
      
      getAvailableTimeSlots(providerId, formattedDate);
    }
  }, [selectedDate, user?.id, getAvailableTimeSlots, clearTimeSlots]);
  
  // Handle next button click
  const handleNext = () => {
    const errors: { [key: string]: string } = {};
    
    // Validate current step
    if (activeStep === 0) {
      if (selectedServices.length === 0) {
        errors.services = 'Selectați cel puțin un serviciu';
      }
    } else if (activeStep === 1) {
      if (!selectedDate) {
        errors.date = 'Selectați o dată';
      }
      if (!selectedTimeSlot) {
        errors.time = 'Selectați o oră';
      }
    }
    
    // If there are errors, show them and don't proceed
    if (Object.keys(errors).length > 0) {
      setFormErrors(errors);
      return;
    }
    
    // Clear any previous errors
    setFormErrors({});
    
    // If this is the last step, create the appointment
    if (activeStep === steps.length - 1) {
      handleCreateAppointment();
    } else {
      // Otherwise, go to next step
      setActiveStep((prevActiveStep) => prevActiveStep + 1);
    }
  };
  
  // Handle back button click
  const handleBack = () => {
    setActiveStep((prevActiveStep) => prevActiveStep - 1);
  };
  
  // Handle service selection
  const handleServiceToggle = (service: Service) => {
    setSelectedServices((prev) => {
      const serviceIndex = prev.findIndex(s => s.id === service.id);
      if (serviceIndex === -1) {
        // Add service
        return [...prev, service];
      } else {
        // Remove service
        return prev.filter(s => s.id !== service.id);
      }
    });
  };
  
  // Handle time slot selection
  const handleTimeSlotSelect = (timeSlot: string) => {
    setSelectedTimeSlot(timeSlot);
  };
  
  // Create appointment
  const handleCreateAppointment = async () => {
    if (!user?.id || !selectedTimeSlot) return;
    
    // TODO: Replace with actual provider ID, for now using 1
    const providerId = 1;
    
    const appointmentData = {
      clientId: user.id,
      providerId: providerId,
      startTime: selectedTimeSlot,
      serviceIds: selectedServices.map(service => service.id),
      notes: notes.trim() || undefined
    };
    
    const result = await createAppointment(appointmentData);
    
    if (result) {
      navigate('/appointments');
    }
  };
  
  // Render step content based on active step
  const getStepContent = (step: number) => {
    switch (step) {
      case 0:
        return (
          <Box>
            <Typography variant="h6" gutterBottom>
              Selectați serviciile dorite
            </Typography>
            
            {formErrors.services && (
              <Alert severity="error" sx={{ mb: 2 }}>
                {formErrors.services}
              </Alert>
            )}
            
            <Grid container spacing={3}>
              {services.map((service) => (
                <Grid item xs={12} sm={6} md={4} key={service.id}>
                  <Card 
                    variant="outlined"
                    sx={{ 
                      height: '100%',
                      border: selectedServices.some(s => s.id === service.id) 
                        ? '2px solid' 
                        : '1px solid',
                      borderColor: selectedServices.some(s => s.id === service.id)
                        ? 'primary.main'
                        : 'divider'
                    }}
                  >
                    <CardActionArea 
                      onClick={() => handleServiceToggle(service)}
                      sx={{ height: '100%', display: 'flex', flexDirection: 'column', alignItems: 'stretch' }}
                    >
                      {service.imageUrl && (
                        <CardMedia
                          component="img"
                          height="140"
                          image={service.imageUrl}
                          alt={service.name}
                        />
                      )}
                      <CardContent sx={{ flexGrow: 1 }}>
                        <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'flex-start' }}>
                          <Typography variant="h6" component="div">
                            {service.name}
                          </Typography>
                          {selectedServices.some(s => s.id === service.id) && (
                            <CheckCircleIcon color="primary" />
                          )}
                        </Box>
                        
                        {service.description && (
                          <Typography variant="body2" color="text.secondary" sx={{ mt: 1 }}>
                            {service.description}
                          </Typography>
                        )}
                        
                        <Box sx={{ display: 'flex', justifyContent: 'space-between', mt: 2 }}>
                          <Typography variant="body2" color="text.secondary">
                            <TimeIcon fontSize="small" sx={{ verticalAlign: 'middle', mr: 0.5 }} />
                            {service.durationMinutes} min
                          </Typography>
                          <Typography variant="subtitle1">
                            {service.price} lei
                          </Typography>
                        </Box>
                      </CardContent>
                    </CardActionArea>
                  </Card>
                </Grid>
              ))}
            </Grid>
            
            {selectedServices.length > 0 && (
              <Paper variant="outlined" sx={{ mt: 3, p: 2 }}>
                <Typography variant="subtitle1" gutterBottom>
                  Servicii selectate:
                </Typography>
                {selectedServices.map((service) => (
                  <Box key={service.id} sx={{ display: 'flex', justifyContent: 'space-between', mb: 1 }}>
                    <Typography variant="body1">
                      {service.name} ({service.durationMinutes} min)
                    </Typography>
                    <Typography variant="body1">
                      {service.price} lei
                    </Typography>
                  </Box>
                ))}
                <Divider sx={{ my: 1 }} />
                <Box sx={{ display: 'flex', justifyContent: 'space-between' }}>
                  <Typography variant="subtitle1">
                    Durată totală: {totalDuration} min
                  </Typography>
                  <Typography variant="subtitle1">
                    Total: {totalPrice} lei
                  </Typography>
                </Box>
              </Paper>
            )}
          </Box>
        );
      case 1:
        return (
          <Box>
            <Typography variant="h6" gutterBottom>
              Selectați data și ora
            </Typography>
            
            <Grid container spacing={3}>
              <Grid item xs={12} md={6}>
                <LocalizationProvider dateAdapter={AdapterDateFns}>
                  <DatePicker 
                    label="Data programării"
                    value={selectedDate}
                    onChange={(newDate) => setSelectedDate(newDate)}
                    disablePast
                    maxDate={addDays(new Date(), 30)} // Allow booking up to 30 days ahead
                    slotProps={{ 
                      textField: { 
                        fullWidth: true,
                        error: !!formErrors.date,
                        helperText: formErrors.date
                      } 
                    }}
                  />
                </LocalizationProvider>
              </Grid>
            </Grid>
            
            <Typography variant="subtitle1" sx={{ mt: 3, mb: 2 }}>
              Ore disponibile:
            </Typography>
            
            {!selectedDate ? (
              <Alert severity="info">
                Selectați o dată pentru a vedea orele disponibile
              </Alert>
            ) : isLoading ? (
              <Box sx={{ display: 'flex', justifyContent: 'center', p: 4 }}>
                <CircularProgress />
              </Box>
            ) : availableTimeSlots.length === 0 ? (
              <Alert severity="warning">
                Nu există ore disponibile pentru data selectată. Vă rugăm să selectați o altă dată.
              </Alert>
            ) : (
              <>
                {formErrors.time && (
                  <Alert severity="error" sx={{ mb: 2 }}>
                    {formErrors.time}
                  </Alert>
                )}
                
                <FormControl component="fieldset">
                  <RadioGroup 
                    value={selectedTimeSlot || ''}
                    onChange={(e) => handleTimeSlotSelect(e.target.value)}
                  >
                    <Grid container spacing={2}>
                      {availableTimeSlots
                        .filter(slot => slot.available)
                        .map((timeSlot, index) => (
                          <Grid item xs={6} sm={4} md={3} key={index}>
                            <FormControlLabel
                              value={timeSlot.startTime}
                              control={<Radio />}
                              label={format(parseISO(timeSlot.startTime), 'HH:mm')}
                              sx={{
                                display: 'flex',
                                border: '1px solid',
                                borderColor: 'divider',
                                borderRadius: 1,
                                p: 1,
                                width: '100%',
                                m: 0
                              }}
                            />
                          </Grid>
                        ))}
                    </Grid>
                  </RadioGroup>
                </FormControl>
              </>
            )}
            
            <Typography variant="subtitle1" sx={{ mt: 4, mb: 2 }}>
              Note (opțional):
            </Typography>
            <TextField
              multiline
              rows={3}
              fullWidth
              placeholder="Adăugați orice informații suplimentare pentru programarea dvs."
              value={notes}
              onChange={(e) => setNotes(e.target.value)}
              inputProps={{ maxLength: 500 }}
            />
          </Box>
        );
      case 2:
        return (
          <Box>
            <Typography variant="h6" gutterBottom>
              Confirmarea programării
            </Typography>
            
            <Paper variant="outlined" sx={{ p: 3, mb: 3 }}>
              <Grid container spacing={2}>
                <Grid item xs={12}>
                  <Typography variant="subtitle1">
                    Servicii selectate:
                  </Typography>
                  {selectedServices.map((service) => (
                    <Box key={service.id} sx={{ display: 'flex', justifyContent: 'space-between', mt: 1 }}>
                      <Typography variant="body1">
                        {service.name} ({service.durationMinutes} min)
                      </Typography>
                      <Typography variant="body1">
                        {service.price} lei
                      </Typography>
                    </Box>
                  ))}
                </Grid>
                
                <Grid item xs={12}>
                  <Divider sx={{ my: 2 }} />
                </Grid>
                
                <Grid item xs={12} sm={6}>
                  <Box sx={{ display: 'flex', alignItems: 'center' }}>
                    <CalendarIcon sx={{ mr: 1, color: 'primary.main' }} />
                    <Typography variant="body1">
                      Data: {selectedDate ? format(selectedDate, 'dd MMMM yyyy') : ''}
                    </Typography>
                  </Box>
                </Grid>
                
                <Grid item xs={12} sm={6}>
                  <Box sx={{ display: 'flex', alignItems: 'center' }}>
                    <TimeIcon sx={{ mr: 1, color: 'primary.main' }} />
                    <Typography variant="body1">
                      Ora: {selectedTimeSlot ? format(parseISO(selectedTimeSlot), 'HH:mm') : ''}
                    </Typography>
                  </Box>
                </Grid>
                
                {notes && (
                  <Grid item xs={12}>
                    <Typography variant="subtitle1" sx={{ mt: 1 }}>
                      Note:
                    </Typography>
                    <Typography variant="body1">
                      {notes}
                    </Typography>
                  </Grid>
                )}
                
                <Grid item xs={12}>
                  <Divider sx={{ my: 2 }} />
                </Grid>
                
                <Grid item xs={12}>
                  <Box sx={{ display: 'flex', justifyContent: 'space-between' }}>
                    <Typography variant="subtitle1">
                      Durată totală:
                    </Typography>
                    <Typography variant="subtitle1">
                      {totalDuration} min
                    </Typography>
                  </Box>
                </Grid>
                
                <Grid item xs={12}>
                  <Box sx={{ display: 'flex', justifyContent: 'space-between' }}>
                    <Typography variant="subtitle1">
                      Preț total:
                    </Typography>
                    <Typography variant="h6" color="primary.main">
                      {totalPrice} lei
                    </Typography>
                  </Box>
                </Grid>
              </Grid>
            </Paper>
            
            <Alert severity="info" sx={{ mb: 2 }}>
              Odată creată, programarea va avea inițial statusul "În așteptare" și va fi confirmată de către salon.
            </Alert>
          </Box>
        );
      default:
        return 'Unknown step';
    }
  };
  
  return (
    <Container maxWidth="md" sx={{ mt: 4, mb: 6 }}>
      <Paper sx={{ p: 3 }}>
        <Typography variant="h4" component="h1" align="center" gutterBottom>
          Programare nouă
        </Typography>
        
        {error && (
          <Alert severity="error" sx={{ mb: 3 }}>
            {error}
          </Alert>
        )}
        
        <Stepper activeStep={activeStep} sx={{ mb: 4 }}>
          {steps.map((label) => (
            <Step key={label}>
              <StepLabel>{label}</StepLabel>
            </Step>
          ))}
        </Stepper>
        
        {getStepContent(activeStep)}
        
        <Box sx={{ display: 'flex', justifyContent: 'space-between', mt: 4 }}>
          <Button
            disabled={activeStep === 0 || isLoading}
            onClick={handleBack}
          >
            Înapoi
          </Button>
          
          <Button
            variant="contained"
            color="primary"
            onClick={handleNext}
            disabled={isLoading}
          >
            {isLoading ? (
              <CircularProgress size={24} color="inherit" />
            ) : activeStep === steps.length - 1 ? (
              'Confirmă programarea'
            ) : (
              'Continuă'
            )}
          </Button>
        </Box>
      </Paper>
    </Container>
  );
};

export default NewAppointmentPage;

================
File: src/pages/NotFoundPage.tsx
================
import React from 'react';
import { Link as RouterLink } from 'react-router-dom';
import {
  Box,
  Container,
  Typography,
  Button,
  Paper
} from '@mui/material';
import { Home as HomeIcon } from '@mui/icons-material';

const NotFoundPage: React.FC = () => {
  return (
    <Container maxWidth="md">
      <Paper
        elevation={3}
        sx={{
          my: 8,
          p: 6,
          display: 'flex',
          flexDirection: 'column',
          alignItems: 'center',
          textAlign: 'center'
        }}
      >
        <Typography variant="h1" component="h1" sx={{ fontWeight: 'bold', mb: 2 }}>
          404
        </Typography>
        
        <Typography variant="h4" component="h2" gutterBottom>
          Pagină Negăsită
        </Typography>
        
        <Typography variant="body1" color="text.secondary" paragraph>
          Pagina pe care o cauți este posibil să fi fost eliminată, să-și fi schimbat numele
          sau este temporar indisponibilă.
        </Typography>
        
        <Box component="img" 
          src="/api/placeholder/400/300" 
          alt="Pagină negăsită" 
          sx={{ 
            width: '100%',
            maxWidth: 400,
            my: 4
          }}
        />
        
        <Button
          component={RouterLink}
          to="/"
          variant="contained"
          color="primary"
          startIcon={<HomeIcon />}
          size="large"
        >
          Înapoi la Pagina Principală
        </Button>
      </Paper>
    </Container>
  );
};

export default NotFoundPage;

================
File: src/pages/RegisterPage.tsx
================
import React, { useEffect } from 'react';
import { useNavigate } from 'react-router-dom';
import { Container } from '@mui/material';
import RegisterForm from '../components/auth/RegisterForm';
import { useAuth } from '../hooks/useAuth';

const RegisterPage: React.FC = () => {
  const { isAuthenticated } = useAuth();
  const navigate = useNavigate();
  
  // Redirect if already authenticated
  useEffect(() => {
    if (isAuthenticated) {
      navigate('/dashboard');
    }
  }, [isAuthenticated, navigate]);
  
  return (
    <Container>
      <RegisterForm />
    </Container>
  );
};

export default RegisterPage;

================
File: src/pages/ServiceManagementPage.tsx
================
// src/pages/ServiceManagementPage.tsx
import React, { useEffect, useState } from 'react';
import { useAuth } from '../hooks/useAuth';
import { useAppointments } from '../hooks/useAppointments';
import * as appointmentApi from '../utils/appointmentApi';
import { Service } from '../types/appointment';
import {
  Container,
  Typography,
  Box,
  Paper,
  Table,
  TableBody,
  TableCell,
  TableContainer,
  TableHead,
  TableRow,
  Button,
  IconButton,
  Switch,
  Dialog,
  DialogTitle,
  DialogContent,
  DialogActions,
  TextField,
  InputAdornment,
  FormControlLabel,
  CircularProgress,
  Alert,
  Snackbar
} from '@mui/material';
import {
  Add as AddIcon,
  Edit as EditIcon,
  DeleteOutline as DeleteIcon,
  AccessTime as TimeIcon
} from '@mui/icons-material';

const ServiceManagementPage: React.FC = () => {
  const { user } = useAuth();
  const { services, getServices, isLoading, error } = useAppointments();
  
  // UI State
  const [openDialog, setOpenDialog] = useState(false);
  const [dialogMode, setDialogMode] = useState<'add' | 'edit'>('add');
  const [selectedService, setSelectedService] = useState<Service | null>(null);
  const [snackbarOpen, setSnackbarOpen] = useState(false);
  const [snackbarMessage, setSnackbarMessage] = useState('');
  const [snackbarSeverity, setSnackbarSeverity] = useState<'success' | 'error'>('success');
  
  // Form State
  const [formName, setFormName] = useState('');
  const [formDescription, setFormDescription] = useState('');
  const [formPrice, setFormPrice] = useState('');
  const [formDuration, setFormDuration] = useState('');
  const [formActive, setFormActive] = useState(true);
  const [formImageUrl, setFormImageUrl] = useState('');
  const [formErrors, setFormErrors] = useState<{ [key: string]: string }>({});
  
  // Check if user has admin role
  const isAdmin = user?.roles.includes('ROLE_ADMIN');
  
  // Fetch services on mount
  useEffect(() => {
    getServices(false); // Get all services, not just active ones
  }, [getServices]);
  
  // Open dialog for adding a new service
  const handleAddService = () => {
    setDialogMode('add');
    setSelectedService(null);
    resetForm();
    setOpenDialog(true);
  };
  
  // Open dialog for editing an existing service
  const handleEditService = (service: Service) => {
    setDialogMode('edit');
    setSelectedService(service);
    
    // Populate form with service data
    setFormName(service.name);
    setFormDescription(service.description || '');
    setFormPrice(service.price.toString());
    setFormDuration(service.durationMinutes.toString());
    setFormActive(service.active);
    setFormImageUrl(service.imageUrl || '');
    
    setOpenDialog(true);
  };
  
  // Reset form fields
  const resetForm = () => {
    setFormName('');
    setFormDescription('');
    setFormPrice('');
    setFormDuration('');
    setFormActive(true);
    setFormImageUrl('');
    setFormErrors({});
  };
  
  // Handle dialog close
  const handleCloseDialog = () => {
    setOpenDialog(false);
    resetForm();
  };
  
  // Validate form
  const validateForm = (): boolean => {
    const errors: { [key: string]: string } = {};
    
    if (!formName.trim()) {
      errors.name = 'Numele serviciului este obligatoriu';
    }
    
    if (!formPrice.trim()) {
      errors.price = 'Prețul este obligatoriu';
    } else if (isNaN(parseFloat(formPrice)) || parseFloat(formPrice) < 0) {
      errors.price = 'Prețul trebuie să fie un număr pozitiv';
    }
    
    if (!formDuration.trim()) {
      errors.duration = 'Durata este obligatorie';
    } else if (isNaN(parseInt(formDuration)) || parseInt(formDuration) <= 0) {
      errors.duration = 'Durata trebuie să fie un număr pozitiv';
    }
    
    setFormErrors(errors);
    return Object.keys(errors).length === 0;
  };
  
  // Handle save service
  const handleSaveService = async () => {
    if (!validateForm()) return;
    
    const serviceData: Service = {
      id: selectedService?.id || 0,
      name: formName,
      description: formDescription || undefined,
      price: parseFloat(formPrice),
      durationMinutes: parseInt(formDuration),
      active: formActive,
      imageUrl: formImageUrl || undefined
    };
    
    try {
      if (dialogMode === 'add') {
        await appointmentApi.createService(serviceData);
        showSnackbar('Serviciu adăugat cu succes', 'success');
      } else {
        await appointmentApi.updateService(serviceData.id, serviceData);
        showSnackbar('Serviciu actualizat cu succes', 'success');
      }
      
      // Refresh services list
      getServices(false);
      handleCloseDialog();
    } catch (error) {
      showSnackbar('A apărut o eroare la salvarea serviciului', 'error');
    }
  };
  
  // Handle toggle service active status
  const handleToggleActive = async (service: Service, newStatus: boolean) => {
    try {
      await appointmentApi.setServiceActiveStatus(service.id, newStatus);
      showSnackbar(`Serviciu ${newStatus ? 'activat' : 'dezactivat'} cu succes`, 'success');
      
      // Refresh services list
      getServices(false);
    } catch (error) {
      showSnackbar('A apărut o eroare la modificarea statusului', 'error');
    }
  };
  
  // Show snackbar message
  const showSnackbar = (message: string, severity: 'success' | 'error') => {
    setSnackbarMessage(message);
    setSnackbarSeverity(severity);
    setSnackbarOpen(true);
  };
  
  // Handle snackbar close
  const handleSnackbarClose = () => {
    setSnackbarOpen(false);
  };
  
  return (
    <Container maxWidth="lg" sx={{ mt: 4, mb: 4 }}>
      <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', mb: 3 }}>
        <Typography variant="h4" component="h1">
          Gestionare Servicii
        </Typography>
        
        {isAdmin && (
          <Button
            variant="contained"
            color="primary"
            startIcon={<AddIcon />}
            onClick={handleAddService}
          >
            Adaugă Serviciu
          </Button>
        )}
      </Box>
      
      {error && (
        <Alert severity="error" sx={{ mb: 3 }}>
          {error}
        </Alert>
      )}
      
      {isLoading ? (
        <Box sx={{ display: 'flex', justifyContent: 'center', p: 4 }}>
          <CircularProgress />
        </Box>
      ) : services.length === 0 ? (
        <Alert severity="info">
          Nu există servicii disponibile. Adăugați primul serviciu.
        </Alert>
      ) : (
        <TableContainer component={Paper}>
          <Table>
            <TableHead>
              <TableRow>
                <TableCell>Nume</TableCell>
                <TableCell>Descriere</TableCell>
                <TableCell align="right">Durată (min)</TableCell>
                <TableCell align="right">Preț (lei)</TableCell>
                <TableCell align="center">Activ</TableCell>
                {isAdmin && <TableCell align="center">Acțiuni</TableCell>}
              </TableRow>
            </TableHead>
            <TableBody>
              {services.map((service) => (
                <TableRow key={service.id}>
                  <TableCell component="th" scope="row">
                    {service.name}
                  </TableCell>
                  <TableCell>{service.description || '-'}</TableCell>
                  <TableCell align="right">
                    <Box sx={{ display: 'flex', alignItems: 'center', justifyContent: 'flex-end' }}>
                      <TimeIcon fontSize="small" sx={{ mr: 1 }} />
                      {service.durationMinutes}
                    </Box>
                  </TableCell>
                  <TableCell align="right">{service.price}</TableCell>
                  <TableCell align="center">
                    {isAdmin ? (
                      <Switch
                        checked={service.active}
                        onChange={(e) => handleToggleActive(service, e.target.checked)}
                        color="primary"
                      />
                    ) : (
                      service.active ? 'Da' : 'Nu'
                    )}
                  </TableCell>
                  {isAdmin && (
                    <TableCell align="center">
                      <IconButton
                        color="primary"
                        onClick={() => handleEditService(service)}
                        size="small"
                      >
                        <EditIcon />
                      </IconButton>
                    </TableCell>
                  )}
                </TableRow>
              ))}
            </TableBody>
          </Table>
        </TableContainer>
      )}
      
      {/* Add/Edit Service Dialog */}
      <Dialog open={openDialog} onClose={handleCloseDialog} maxWidth="sm" fullWidth>
        <DialogTitle>
          {dialogMode === 'add' ? 'Adaugă Serviciu Nou' : 'Editează Serviciu'}
        </DialogTitle>
        <DialogContent>
          <Box component="form" noValidate sx={{ mt: 2 }}>
            <TextField
              fullWidth
              label="Nume Serviciu"
              margin="normal"
              value={formName}
              onChange={(e) => setFormName(e.target.value)}
              error={!!formErrors.name}
              helperText={formErrors.name}
              required
            />
            
            <TextField
              fullWidth
              label="Descriere"
              margin="normal"
              value={formDescription}
              onChange={(e) => setFormDescription(e.target.value)}
              multiline
              rows={3}
            />
            
            <Box sx={{ display: 'flex', gap: 2, mt: 2 }}>
              <TextField
                fullWidth
                label="Preț"
                margin="normal"
                value={formPrice}
                onChange={(e) => setFormPrice(e.target.value)}
                error={!!formErrors.price}
                helperText={formErrors.price}
                InputProps={{
                  endAdornment: <InputAdornment position="end">lei</InputAdornment>,
                }}
                required
              />
              
              <TextField
                fullWidth
                label="Durată"
                margin="normal"
                value={formDuration}
                onChange={(e) => setFormDuration(e.target.value)}
                error={!!formErrors.duration}
                helperText={formErrors.duration}
                InputProps={{
                  endAdornment: <InputAdornment position="end">min</InputAdornment>,
                }}
                required
              />
            </Box>
            
            <TextField
              fullWidth
              label="URL Imagine"
              margin="normal"
              value={formImageUrl}
              onChange={(e) => setFormImageUrl(e.target.value)}
              placeholder="https://example.com/image.jpg"
            />
            
            <FormControlLabel
              control={
                <Switch
                  checked={formActive}
                  onChange={(e) => setFormActive(e.target.checked)}
                  color="primary"
                />
              }
              label="Serviciu Activ"
              sx={{ mt: 2 }}
            />
          </Box>
        </DialogContent>
        <DialogActions>
          <Button onClick={handleCloseDialog}>Anulează</Button>
          <Button onClick={handleSaveService} variant="contained" color="primary">
            Salvează
          </Button>
        </DialogActions>
      </Dialog>
      
      {/* Snackbar for notifications */}
      <Snackbar
        open={snackbarOpen}
        autoHideDuration={6000}
        onClose={handleSnackbarClose}
        anchorOrigin={{ vertical: 'bottom', horizontal: 'center' }}
      >
        <Alert
          onClose={handleSnackbarClose}
          severity={snackbarSeverity}
          variant="filled"
          sx={{ width: '100%' }}
        >
          {snackbarMessage}
        </Alert>
      </Snackbar>
    </Container>
  );
};

export default ServiceManagementPage;

================
File: src/store/appointmentSlice.ts
================
// src/store/appointmentSlice.ts
import { createSlice, createAsyncThunk, PayloadAction } from '@reduxjs/toolkit';
import * as appointmentApi from '../utils/appointmentApi';
import { 
  Appointment, 
  Service, 
  CreateAppointmentRequest,
  UpdateAppointmentRequest,
  AvailableTimeSlotsResponse,
  TimeSlot
} from '../types/appointment';

interface AppointmentState {
  appointments: Appointment[];
  currentAppointment: Appointment | null;
  services: Service[];
  availableTimeSlots: TimeSlot[];
  isLoading: boolean;
  error: string | null;
}

const initialState: AppointmentState = {
  appointments: [],
  currentAppointment: null,
  services: [],
  availableTimeSlots: [],
  isLoading: false,
  error: null
};

// Async thunks for appointments
export const fetchClientAppointments = createAsyncThunk(
  'appointments/fetchClientAppointments',
  async (clientId: number, { rejectWithValue }) => {
    try {
      return await appointmentApi.getClientAppointments(clientId);
    } catch (error: any) {
      return rejectWithValue(error.response?.data?.detail || 'Failed to fetch appointments');
    }
  }
);

export const fetchProviderAppointments = createAsyncThunk(
  'appointments/fetchProviderAppointments',
  async (providerId: number, { rejectWithValue }) => {
    try {
      return await appointmentApi.getProviderAppointments(providerId);
    } catch (error: any) {
      return rejectWithValue(error.response?.data?.detail || 'Failed to fetch appointments');
    }
  }
);

export const fetchAppointmentById = createAsyncThunk(
  'appointments/fetchAppointmentById',
  async (id: number, { rejectWithValue }) => {
    try {
      return await appointmentApi.getAppointmentById(id);
    } catch (error: any) {
      return rejectWithValue(error.response?.data?.detail || 'Failed to fetch appointment');
    }
  }
);

export const createNewAppointment = createAsyncThunk(
  'appointments/createAppointment',
  async (request: CreateAppointmentRequest, { rejectWithValue }) => {
    try {
      return await appointmentApi.createAppointment(request);
    } catch (error: any) {
      return rejectWithValue(error.response?.data?.detail || 'Failed to create appointment');
    }
  }
);

export const updateExistingAppointment = createAsyncThunk(
  'appointments/updateAppointment',
  async ({ id, request }: { id: number, request: UpdateAppointmentRequest }, { rejectWithValue }) => {
    try {
      return await appointmentApi.updateAppointment(id, request);
    } catch (error: any) {
      return rejectWithValue(error.response?.data?.detail || 'Failed to update appointment');
    }
  }
);

export const cancelExistingAppointment = createAsyncThunk(
  'appointments/cancelAppointment',
  async (id: number, { rejectWithValue }) => {
    try {
      return await appointmentApi.cancelAppointment(id);
    } catch (error: any) {
      return rejectWithValue(error.response?.data?.detail || 'Failed to cancel appointment');
    }
  }
);

export const fetchAvailableTimeSlots = createAsyncThunk(
  'appointments/fetchAvailableTimeSlots',
  async ({ providerId, date }: { providerId: number, date: string }, { rejectWithValue }) => {
    try {
      return await appointmentApi.getAvailableTimeSlots(providerId, date);
    } catch (error: any) {
      return rejectWithValue(error.response?.data?.detail || 'Failed to fetch available time slots');
    }
  }
);

// Async thunks for services
export const fetchServices = createAsyncThunk(
  'appointments/fetchServices',
  async (activeOnly: boolean = true, { rejectWithValue }) => {
    try {
      return await appointmentApi.getAllServices(activeOnly);
    } catch (error: any) {
      return rejectWithValue(error.response?.data?.detail || 'Failed to fetch services');
    }
  }
);

const appointmentSlice = createSlice({
  name: 'appointments',
  initialState,
  reducers: {
    resetAppointmentError: (state) => {
      state.error = null;
    },
    resetCurrentAppointment: (state) => {
      state.currentAppointment = null;
    },
    clearAvailableTimeSlots: (state) => {
      state.availableTimeSlots = [];
    }
  },
  extraReducers: (builder) => {
    // Fetch client appointments
    builder
      .addCase(fetchClientAppointments.pending, (state) => {
        state.isLoading = true;
        state.error = null;
      })
      .addCase(fetchClientAppointments.fulfilled, (state, action: PayloadAction<Appointment[]>) => {
        state.isLoading = false;
        state.appointments = action.payload;
      })
      .addCase(fetchClientAppointments.rejected, (state, action) => {
        state.isLoading = false;
        state.error = action.payload as string;
      })
    
    // Fetch provider appointments
    builder
      .addCase(fetchProviderAppointments.pending, (state) => {
        state.isLoading = true;
        state.error = null;
      })
      .addCase(fetchProviderAppointments.fulfilled, (state, action: PayloadAction<Appointment[]>) => {
        state.isLoading = false;
        state.appointments = action.payload;
      })
      .addCase(fetchProviderAppointments.rejected, (state, action) => {
        state.isLoading = false;
        state.error = action.payload as string;
      })
    
    // Fetch appointment by ID
    builder
      .addCase(fetchAppointmentById.pending, (state) => {
        state.isLoading = true;
        state.error = null;
      })
      .addCase(fetchAppointmentById.fulfilled, (state, action: PayloadAction<Appointment>) => {
        state.isLoading = false;
        state.currentAppointment = action.payload;
      })
      .addCase(fetchAppointmentById.rejected, (state, action) => {
        state.isLoading = false;
        state.error = action.payload as string;
      })
    
    // Create appointment
    builder
      .addCase(createNewAppointment.pending, (state) => {
        state.isLoading = true;
        state.error = null;
      })
      .addCase(createNewAppointment.fulfilled, (state, action: PayloadAction<Appointment>) => {
        state.isLoading = false;
        state.appointments.push(action.payload);
        state.currentAppointment = action.payload;
      })
      .addCase(createNewAppointment.rejected, (state, action) => {
        state.isLoading = false;
        state.error = action.payload as string;
      })
    
    // Update appointment
    builder
      .addCase(updateExistingAppointment.pending, (state) => {
        state.isLoading = true;
        state.error = null;
      })
      .addCase(updateExistingAppointment.fulfilled, (state, action: PayloadAction<Appointment>) => {
        state.isLoading = false;
        const index = state.appointments.findIndex(apt => apt.id === action.payload.id);
        if (index !== -1) {
          state.appointments[index] = action.payload;
        }
        state.currentAppointment = action.payload;
      })
      .addCase(updateExistingAppointment.rejected, (state, action) => {
        state.isLoading = false;
        state.error = action.payload as string;
      })
    
    // Cancel appointment
    builder
      .addCase(cancelExistingAppointment.pending, (state) => {
        state.isLoading = true;
        state.error = null;
      })
      .addCase(cancelExistingAppointment.fulfilled, (state, action: PayloadAction<Appointment>) => {
        state.isLoading = false;
        const index = state.appointments.findIndex(apt => apt.id === action.payload.id);
        if (index !== -1) {
          state.appointments[index] = action.payload;
        }
        if (state.currentAppointment?.id === action.payload.id) {
          state.currentAppointment = action.payload;
        }
      })
      .addCase(cancelExistingAppointment.rejected, (state, action) => {
        state.isLoading = false;
        state.error = action.payload as string;
      })
    
    // Fetch available time slots
    builder
      .addCase(fetchAvailableTimeSlots.pending, (state) => {
        state.isLoading = true;
        state.error = null;
      })
      .addCase(fetchAvailableTimeSlots.fulfilled, (state, action: PayloadAction<AvailableTimeSlotsResponse>) => {
        state.isLoading = false;
        state.availableTimeSlots = action.payload.availableSlots;
      })
      .addCase(fetchAvailableTimeSlots.rejected, (state, action) => {
        state.isLoading = false;
        state.error = action.payload as string;
      })
    
    // Fetch services
    builder
      .addCase(fetchServices.pending, (state) => {
        state.isLoading = true;
        state.error = null;
      })
      .addCase(fetchServices.fulfilled, (state, action: PayloadAction<Service[]>) => {
        state.isLoading = false;
        state.services = action.payload;
      })
      .addCase(fetchServices.rejected, (state, action) => {
        state.isLoading = false;
        state.error = action.payload as string;
      });
  }
});

export const { 
  resetAppointmentError, 
  resetCurrentAppointment,
  clearAvailableTimeSlots
} = appointmentSlice.actions;

export default appointmentSlice.reducer;

================
File: src/store/authSlice.ts
================
import { createSlice, createAsyncThunk, PayloadAction } from '@reduxjs/toolkit';
import api from '../utils/axios';
import { 
  AuthState, 
  LoginRequest, 
  RegisterRequest, 
  JwtResponse,
  User 
} from '../types';
import { 
  setAccessToken, 
  setRefreshToken, 
  clearTokens 
} from '../utils/tokenUtils';

// Initial state
const initialState: AuthState = {
  user: null,
  isAuthenticated: false,
  isLoading: false,
  error: null
};

// Async thunks
export const login = createAsyncThunk(
  'auth/login',
  async (credentials: LoginRequest, { rejectWithValue }) => {
    try {
      const response = await api.post<JwtResponse>('/auth/login', credentials);
      return response.data;
    } catch (error: any) {
      return rejectWithValue(error.response?.data?.detail || 'Login failed');
    }
  }
);

export const register = createAsyncThunk(
  'auth/register',
  async (userData: RegisterRequest, { rejectWithValue }) => {
    try {
      const response = await api.post<User>('/auth/register', userData);
      return response.data;
    } catch (error: any) {
      return rejectWithValue(error.response?.data?.detail || 'Registration failed');
    }
  }
);

export const getCurrentUser = createAsyncThunk(
  'auth/getCurrentUser',
  async (_, { rejectWithValue }) => {
    try {
      const response = await api.get<User>('/users/me');
      return response.data;
    } catch (error: any) {
      return rejectWithValue(error.response?.data?.detail || 'Failed to get user data');
    }
  }
);

export const logout = createAsyncThunk(
  'auth/logout',
  async (_, { rejectWithValue }) => {
    try {
      await api.post('/auth/logout');
      clearTokens();
      return true;
    } catch (error: any) {
      // Even if the server request fails, we should clear local tokens
      clearTokens();
      return rejectWithValue(error.response?.data?.detail || 'Logout failed');
    }
  }
);

// Auth slice
const authSlice = createSlice({
  name: 'auth',
  initialState,
  reducers: {
    resetAuthError: (state) => {
      state.error = null;
    },
  },
  extraReducers: (builder) => {
    // Login
    builder
      .addCase(login.pending, (state) => {
        state.isLoading = true;
        state.error = null;
      })
      .addCase(login.fulfilled, (state, action: PayloadAction<JwtResponse>) => {
        state.isLoading = false;
        state.isAuthenticated = true;
        state.user = {
          id: action.payload.id,
          email: action.payload.email,
          username: action.payload.username,
          roles: action.payload.roles,
          // These will be populated when we fetch the full user profile
          firstName: '',
          lastName: '',
          country: 'RO' as any,
          active: true
        };
        
        // Store tokens
        setAccessToken(action.payload.token);
        setRefreshToken(action.payload.refreshToken);
      })
      .addCase(login.rejected, (state, action) => {
        state.isLoading = false;
        state.error = action.payload as string;
      })
      
    // Register
    builder
      .addCase(register.pending, (state) => {
        state.isLoading = true;
        state.error = null;
      })
      .addCase(register.fulfilled, (state, action: PayloadAction<User>) => {
        state.isLoading = false;
        // On register success, we don't log in automatically
        // User needs to log in with their credentials
      })
      .addCase(register.rejected, (state, action) => {
        state.isLoading = false;
        state.error = action.payload as string;
      })
      
    // Get current user
    builder
      .addCase(getCurrentUser.pending, (state) => {
        state.isLoading = true;
      })
      .addCase(getCurrentUser.fulfilled, (state, action: PayloadAction<User>) => {
        state.isLoading = false;
        state.isAuthenticated = true;
        state.user = action.payload;
      })
      .addCase(getCurrentUser.rejected, (state, action) => {
        state.isLoading = false;
        state.isAuthenticated = false;
        state.user = null;
        state.error = action.payload as string;
        // Clear tokens if user fetch fails (likely invalid tokens)
        clearTokens();
      })
      
    // Logout
    builder
      .addCase(logout.fulfilled, (state) => {
        state.isAuthenticated = false;
        state.user = null;
      });
  },
});

export const { resetAuthError } = authSlice.actions;
export default authSlice.reducer;

================
File: src/store/store.ts
================
import { configureStore } from '@reduxjs/toolkit';
import authReducer from './authSlice';
import appointmentReducer from './appointmentSlice';

export const store = configureStore({
  reducer: {
    auth: authReducer,
    appointments: appointmentReducer,
  },
});

// Export types for better TypeScript integration
export type RootState = ReturnType<typeof store.getState>;
export type AppDispatch = typeof store.dispatch;

================
File: src/types/appointment.ts
================
import { User } from './index';

export enum AppointmentStatusEnum {
  PENDING = 'PENDING',
  CONFIRMED = 'CONFIRMED',
  CANCELLED = 'CANCELLED',
  COMPLETED = 'COMPLETED',
  NO_SHOW = 'NO_SHOW'
}

export enum ScheduleExceptionTypeEnum {
  DAY_OFF = 'DAY_OFF',
  SPECIAL_HOURS = 'SPECIAL_HOURS'
}

export interface Service {
  id: number;
  name: string;
  description?: string;
  price: number;
  durationMinutes: number;
  active: boolean;
  imageUrl?: string;
}

export interface Appointment {
  id: number;
  clientId: number;
  clientName: string;
  clientEmail: string;
  providerId: number;
  providerName: string;
  startTime: string;
  endTime: string;
  status: AppointmentStatusEnum;
  services: Service[];
  notes?: string;
  totalPrice: number;
}

export interface CreateAppointmentRequest {
  clientId: number;
  providerId: number;
  startTime: string;
  serviceIds: number[];
  notes?: string;
}

export interface UpdateAppointmentRequest {
  id: number;
  startTime?: string;
  serviceIds?: number[];
  notes?: string;
  status?: AppointmentStatusEnum;
}

export interface TimeSlot {
  startTime: string;
  endTime: string;
  durationMinutes: number;
  available: boolean;
}

export interface AvailableTimeSlotsResponse {
  providerId: number;
  date: string;
  availableSlots: TimeSlot[];
}

export interface TimeSlotConfig {
  id?: number;
  slotDurationMinutes: number;
  bufferTimeMinutes: number;
  bookingLeadDays: number;
  bookingAheadDays: number;
}

export interface WorkSchedule {
  id?: number;
  providerId: number;
  dayOfWeek: string; // 'MONDAY', 'TUESDAY', etc.
  startTime: string;
  endTime: string;
  active: boolean;
}

export interface ScheduleException {
  id?: number;
  providerId: number;
  exceptionDate: string;
  type: ScheduleExceptionTypeEnum;
  startTime?: string;
  endTime?: string;
  reason?: string;
}

export interface WeeklySchedule {
  providerId: number;
  providerName: string;
  regularSchedule: WorkSchedule[];
  exceptions: ScheduleException[];
}

export interface SetWorkScheduleRequest {
  providerId: number;
  scheduleEntries: WorkSchedule[];
}

================
File: src/types/index.ts
================
// User types
export enum CountryEnum {
  RO = 'RO',
  MD = 'MD'
}

export interface User {
  id: number;
  username?: string;
  email: string;
  country: CountryEnum;
  firstName: string;
  lastName: string;
  active: boolean;
  roles: string[];
}

// Authentication types
export interface LoginRequest {
  email: string;
  password: string;
}

export interface RegisterRequest {
  email: string;
  password: string;
  country: CountryEnum;
  firstName: string;
  lastName: string;
}

export interface JwtResponse {
  token: string;
  refreshToken: string;
  type: string;
  id: number;
  username?: string;
  email: string;
  roles: string[];
}

export interface RefreshTokenRequest {
  refreshToken: string;
}

export interface RefreshTokenResponse {
  accessToken: string;
  refreshToken: string;
  tokenType: string;
}

// Auth state for store
export interface AuthState {
  user: User | null;
  isAuthenticated: boolean;
  isLoading: boolean;
  error: string | null;
}

================
File: src/utils/appointmentApi.ts
================
import api from './axios';
import { 
  Appointment, 
  Service, 
  CreateAppointmentRequest, 
  UpdateAppointmentRequest,
  AvailableTimeSlotsResponse,
  TimeSlotConfig,
  WeeklySchedule,
  SetWorkScheduleRequest,
  ScheduleException
} from '../types/appointment';

// Appointment API calls
export const getAppointmentById = async (id: number): Promise<Appointment> => {
  const response = await api.get<Appointment>(`/appointments/${id}`);
  return response.data;
};

export const getClientAppointments = async (clientId: number): Promise<Appointment[]> => {
  const response = await api.get<Appointment[]>(`/appointments/client/${clientId}`);
  return response.data;
};

export const getProviderAppointments = async (providerId: number): Promise<Appointment[]> => {
  const response = await api.get<Appointment[]>(`/appointments/provider/${providerId}`);
  return response.data;
};

export const getAppointmentsByDateRange = async (startDate: string, endDate: string): Promise<Appointment[]> => {
  const response = await api.get<Appointment[]>(`/appointments/date-range`, {
    params: { startDate, endDate }
  });
  return response.data;
};

export const createAppointment = async (request: CreateAppointmentRequest): Promise<Appointment> => {
  const response = await api.post<Appointment>('/appointments', request);
  return response.data;
};

export const updateAppointment = async (id: number, request: UpdateAppointmentRequest): Promise<Appointment> => {
  const response = await api.put<Appointment>(`/appointments/${id}`, request);
  return response.data;
};

export const cancelAppointment = async (id: number): Promise<Appointment> => {
  const response = await api.delete<Appointment>(`/appointments/${id}`);
  return response.data;
};

export const getAvailableTimeSlots = async (
  providerId: number, 
  date: string
): Promise<AvailableTimeSlotsResponse> => {
  const response = await api.get<AvailableTimeSlotsResponse>(
    `/appointments/available-slots/${providerId}`,
    { params: { date } }
  );
  return response.data;
};

// Service API calls
export const getAllServices = async (activeOnly: boolean = false): Promise<Service[]> => {
  const response = await api.get<Service[]>('/services', {
    params: { activeOnly }
  });
  return response.data;
};

export const getServiceById = async (id: number): Promise<Service> => {
  const response = await api.get<Service>(`/services/${id}`);
  return response.data;
};

export const createService = async (service: Service): Promise<Service> => {
  const response = await api.post<Service>('/services', service);
  return response.data;
};

export const updateService = async (id: number, service: Service): Promise<Service> => {
  const response = await api.put<Service>(`/services/${id}`, service);
  return response.data;
};

export const setServiceActiveStatus = async (id: number, active: boolean): Promise<Service> => {
  const response = await api.patch<Service>(`/services/${id}/status`, null, {
    params: { active }
  });
  return response.data;
};

// Time Slot Configuration API calls
export const getTimeSlotConfig = async (): Promise<TimeSlotConfig> => {
  const response = await api.get<TimeSlotConfig>('/time-slots/config');
  return response.data;
};

export const updateTimeSlotConfig = async (config: TimeSlotConfig): Promise<TimeSlotConfig> => {
  const response = await api.put<TimeSlotConfig>('/time-slots/config', config);
  return response.data;
};

export const createDefaultTimeSlotConfig = async (): Promise<TimeSlotConfig> => {
  const response = await api.post<TimeSlotConfig>('/time-slots/config/default');
  return response.data;
};

// Work Schedule API calls
export const getProviderSchedule = async (providerId: number): Promise<WeeklySchedule> => {
  const response = await api.get<WeeklySchedule>(`/work-schedules/${providerId}`);
  return response.data;
};

export const setProviderSchedule = async (request: SetWorkScheduleRequest): Promise<WeeklySchedule> => {
  const response = await api.put<WeeklySchedule>('/work-schedules', request);
  return response.data;
};

export const addScheduleException = async (exception: ScheduleException): Promise<ScheduleException> => {
  const response = await api.post<ScheduleException>('/work-schedules/exceptions', exception);
  return response.data;
};

export const updateScheduleException = async (
  id: number, 
  exception: ScheduleException
): Promise<ScheduleException> => {
  const response = await api.put<ScheduleException>(`/work-schedules/exceptions/${id}`, exception);
  return response.data;
};

export const deleteScheduleException = async (id: number): Promise<void> => {
  await api.delete(`/work-schedules/exceptions/${id}`);
};

export const getScheduleExceptionsForDateRange = async (
  providerId: number,
  startDate: string,
  endDate: string
): Promise<ScheduleException[]> => {
  const response = await api.get<ScheduleException[]>(`/work-schedules/exceptions/date-range`, {
    params: { providerId, startDate, endDate }
  });
  return response.data;
};

================
File: src/utils/axios.ts
================
import axios from 'axios';
import { getAccessToken, refreshAccessToken, clearTokens } from './tokenUtils';

// Create axios instance with default configs
const api = axios.create({
  baseURL: 'http://localhost:8080/api',
  headers: {
    'Content-Type': 'application/json',
  },
});

// Add request interceptor to attach Authorization header with JWT token
api.interceptors.request.use(
  (config) => {
    const token = getAccessToken();
    if (token) {
      config.headers['Authorization'] = `Bearer ${token}`;
    }
    return config;
  },
  (error) => {
    return Promise.reject(error);
  }
);

// Add response interceptor to handle token refresh on 401 errors
api.interceptors.response.use(
  (response) => {
    return response;
  },
  async (error) => {
    const originalRequest = error.config;
    
    // If the error is 401 and we haven't already tried to refresh the token
    if (error.response?.status === 401 && !originalRequest._retry) {
      originalRequest._retry = true;
      
      try {
        // Attempt to refresh the token
        await refreshAccessToken();
        
        // Retry the original request with the new token
        const token = getAccessToken();
        if (token) {
          originalRequest.headers['Authorization'] = `Bearer ${token}`;
        }
        return api(originalRequest);
      } catch (refreshError) {
        // If refresh token is invalid, log the user out
        clearTokens();
        window.location.href = '/login';
        return Promise.reject(refreshError);
      }
    }
    
    return Promise.reject(error);
  }
);

export default api;

================
File: src/utils/tokenUtils.ts
================
import axios from 'axios';

// Cookie-based token management
const ACCESS_TOKEN_NAME = 'appointment_access_token';
const REFRESH_TOKEN_NAME = 'appointment_refresh_token';

// Helper to set a cookie with expiration
const setCookie = (name: string, value: string, days: number) => {
  const expires = new Date();
  expires.setTime(expires.getTime() + days * 24 * 60 * 60 * 1000);
  document.cookie = `${name}=${value};expires=${expires.toUTCString()};path=/;SameSite=Strict`;
};

// Helper to get a cookie by name
const getCookie = (name: string): string | null => {
  const match = document.cookie.match(new RegExp('(^| )' + name + '=([^;]+)'));
  return match ? match[2] : null;
};

// Helper to remove a cookie
const removeCookie = (name: string) => {
  document.cookie = `${name}=;expires=Thu, 01 Jan 1970 00:00:00 GMT;path=/;SameSite=Strict`;
};

// Store access token in a cookie (short-lived, 15 minutes)
export const setAccessToken = (token: string) => {
  setCookie(ACCESS_TOKEN_NAME, token, 0.01); // 15 minutes in days
};

// Store refresh token in a cookie (longer-lived, 30 days)
export const setRefreshToken = (token: string) => {
  setCookie(REFRESH_TOKEN_NAME, token, 30);
};

// Get the current access token
export const getAccessToken = (): string | null => {
  return getCookie(ACCESS_TOKEN_NAME);
};

// Get the current refresh token
export const getRefreshToken = (): string | null => {
  return getCookie(REFRESH_TOKEN_NAME);
};

// Clear both tokens (for logout)
export const clearTokens = () => {
  removeCookie(ACCESS_TOKEN_NAME);
  removeCookie(REFRESH_TOKEN_NAME);
};

// Use the refresh token to get a new access token
export const refreshAccessToken = async (): Promise<void> => {
  const refreshToken = getRefreshToken();
  
  if (!refreshToken) {
    throw new Error('No refresh token available');
  }
  
  try {
    const response = await axios.post('http://localhost:8080/api/auth/refreshtoken', {
      refreshToken,
    });
    
    const { accessToken, refreshToken: newRefreshToken } = response.data;
    
    setAccessToken(accessToken);
    
    // If a new refresh token is provided, update it
    if (newRefreshToken) {
      setRefreshToken(newRefreshToken);
    }
  } catch (error) {
    clearTokens();
    throw error;
  }
};

================
File: src/vite-env.d.ts
================
/// <reference types="vite/client" />

================
File: tsconfig.app.json
================
{
  "compilerOptions": {
    "tsBuildInfoFile": "./node_modules/.tmp/tsconfig.app.tsbuildinfo",
    "target": "ES2020",
    "useDefineForClassFields": true,
    "lib": ["ES2020", "DOM", "DOM.Iterable"],
    "module": "ESNext",
    "skipLibCheck": true,

    /* Bundler mode */
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "isolatedModules": true,
    "moduleDetection": "force",
    "noEmit": true,
    "jsx": "react-jsx",

    /* Linting */
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "noFallthroughCasesInSwitch": true,
    "noUncheckedSideEffectImports": true
  },
  "include": ["src"]
}

================
File: tsconfig.json
================
{
  "files": [],
  "references": [
    { "path": "./tsconfig.app.json" },
    { "path": "./tsconfig.node.json" }
  ]
}

================
File: tsconfig.node.json
================
{
  "compilerOptions": {
    "tsBuildInfoFile": "./node_modules/.tmp/tsconfig.node.tsbuildinfo",
    "target": "ES2022",
    "lib": ["ES2023"],
    "module": "ESNext",
    "skipLibCheck": true,

    /* Bundler mode */
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "isolatedModules": true,
    "moduleDetection": "force",
    "noEmit": true,

    /* Linting */
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "noFallthroughCasesInSwitch": true,
    "noUncheckedSideEffectImports": true
  },
  "include": ["vite.config.ts"]
}

================
File: vite.config.ts
================
import { defineConfig } from 'vite'
import react from '@vitejs/plugin-react'

// https://vite.dev/config/
export default defineConfig({
  plugins: [react()],
})
